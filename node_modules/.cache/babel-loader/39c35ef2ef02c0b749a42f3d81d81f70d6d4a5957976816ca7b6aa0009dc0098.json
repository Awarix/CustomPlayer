{"ast":null,"code":"var _jsxFileName = \"/home/gleb/my_app_test/src/audio/r6/Player.tsx\",\n  _s = $RefreshSig$();\n// import React, { useState, useRef, useEffect } from 'react';\n// import { makeStyles } from '@material-ui/core/styles';\n// import { IconButton, Slider } from '@material-ui/core';\n// import { PlayArrow, Pause } from '@material-ui/icons';\n\n// interface PlayerProps {\n//   audioSrc: string;\n//   segments: SegmentModel[];\n//   keywords: KeywordColor[];\n// }\n\n// interface SegmentModel {\n//   Start: number;\n//   End: number;\n//   ChannelNumber: number;\n//   Words?: { NormalForm: string }[];\n// }\n\n// interface KeywordColor {\n//   keyword: {\n//     Start: number;\n//     End: number;\n//     Name: string;\n//     ChannelNumber: number;\n//     Confidence: number;\n//   };\n//   color: string;\n// }\n\n// const useStyles = makeStyles({\n//   root: {\n//     width: '100%',\n//     display: 'flex',\n//     flexDirection: 'column',\n//     alignItems: 'center',\n//   },\n//   controls: {\n//     display: 'flex',\n//     alignItems: 'center',\n//     width: '100%',\n//     marginBottom: 20,\n//     marginTop: 100,\n//   },\n//   canvas: {\n//     width: '100%',\n//     height: 100,\n//     border: '1px solid black', // Added for visibility\n//   },\n// });\n\n// const Player: React.FC<PlayerProps> = ({ audioSrc, segments, keywords }) => {\n//   const classes = useStyles();\n//   const [isPlaying, setIsPlaying] = useState(false);\n//   const [currentTime, setCurrentTime] = useState(0);\n//   const [duration, setDuration] = useState(0);\n\n//   const audioRef = useRef<HTMLAudioElement>(null);\n//   const canvasRef = useRef<HTMLCanvasElement>(null);\n\n//   useEffect(() => {\n//     if (audioRef.current) {\n//       audioRef.current.addEventListener('loadedmetadata', () => {\n//         setDuration(audioRef.current!.duration);\n//       });\n//       audioRef.current.addEventListener('timeupdate', () => {\n//         setCurrentTime(audioRef.current!.currentTime);\n//       });\n//     }\n//   }, []);\n\n//   useEffect(() => {\n//     drawWaveform();\n//   }, [segments, keywords, duration]);\n\n//   const togglePlay = () => {\n//     if (audioRef.current) {\n//       if (isPlaying) {\n//         audioRef.current.pause();\n//       } else {\n//         audioRef.current.play();\n//       }\n//       setIsPlaying(!isPlaying);\n//     }\n//   };\n\n//   const handleSliderChange = (event: any, newValue: number | number[]) => {\n//     if (audioRef.current && typeof newValue === 'number') {\n//       audioRef.current.currentTime = newValue;\n//       setCurrentTime(newValue);\n//     }\n//   };\n\n//   const drawWaveform = () => {\n//     if (canvasRef.current && duration > 0) {\n//       const ctx = canvasRef.current.getContext('2d');\n//       if (ctx) {\n//         const canvasWidth = canvasRef.current.width;\n//         const canvasHeight = canvasRef.current.height;\n\n//         ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n//         console.log(`Drawing ${segments.length} segments and ${keywords.length} keywords`);\n\n//         // Draw segments\n//         segments.forEach((segment, index) => {\n//             const startX = (segment.Start / duration) * canvasWidth;\n//             const endX = (segment.End / duration) * canvasWidth;\n//             ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\"\n//               ? \"rgba(181, 201, 255, 0.5)\"\n//               : \"rgba(0, 123, 255, 0.5)\";\n//             ctx.fillRect(startX, 0, endX - startX, canvasHeight);\n//             console.log(`Drawing segment ${index}: start=${startX}, end=${endX}, color=${ctx.fillStyle}`);\n//           });\n\n//           // Draw keywords\n//           keywords.forEach((kw, index) => {\n//             const startX = (kw.keyword.Start / duration) * canvasWidth;\n//             const width = ((kw.keyword.End - kw.keyword.Start) / duration) * canvasWidth;\n//             ctx.fillStyle = kw.color;\n//             ctx.fillRect(startX, 0, width, canvasHeight / 4);\n//             console.log(`Drawing keyword ${index}: start=${startX}, width=${width}, color=${kw.color}`);\n//           });\n\n//           // Draw current time indicator\n//           const currentTimeX = (currentTime / duration) * canvasWidth;\n//           ctx.strokeStyle = 'red';\n//           ctx.lineWidth = 2;\n//           ctx.beginPath();\n//           ctx.moveTo(currentTimeX, 0);\n//           ctx.lineTo(currentTimeX, canvasHeight);\n//           ctx.stroke();\n//         }\n//       } else {\n//         console.log('Canvas not ready or duration is 0');\n//       }\n//     };\n\n//     const formatTime = (time: number) => {\n//       const minutes = Math.floor(time / 60);\n//       const seconds = Math.floor(time % 60);\n//       return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n//     };\n\n//     return (\n//       <div className={classes.root}>\n//         <audio ref={audioRef} src={audioSrc} />\n//         <div className={classes.controls}>\n//           <IconButton onClick={togglePlay}>\n//             {isPlaying ? <Pause /> : <PlayArrow />}\n//           </IconButton>\n//           <Slider\n//             value={currentTime}\n//             onChange={handleSliderChange}\n//             min={0}\n//             max={duration}\n//             step={0.1}\n//           />\n//           <span>{formatTime(currentTime)} / {formatTime(duration)}</span>\n//         </div>\n//         <canvas \n//           ref={canvasRef} \n//           className={classes.canvas}\n//           width={1000}\n//           height={100}\n//           onClick={(e) => {\n//             const rect = canvasRef.current!.getBoundingClientRect();\n//             const x = e.clientX - rect.left;\n//             const clickTime = (x / canvasRef.current!.width) * duration;\n//             if (audioRef.current) {\n//               audioRef.current.currentTime = clickTime;\n//             }\n//           }}\n//         />\n//         <div>\n//           <p>Segments: {segments.length}</p>\n//           <p>Keywords: {keywords.length}</p>\n//           <p>Duration: {duration}</p>\n//         </div>\n//       </div>\n//     );\n//   };\n\n//   export default Player;\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport { IconButton, Slider, Tooltip } from '@material-ui/core';\nimport { PlayArrow, Pause } from '@material-ui/icons';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst useStyles = makeStyles({\n  root: {\n    width: '100%',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center'\n  },\n  controls: {\n    display: 'flex',\n    alignItems: 'center',\n    width: '100%',\n    margin: '20px 0'\n  },\n  canvasContainer: {\n    width: '100%',\n    display: 'flex',\n    flexDirection: 'column'\n  },\n  canvas: {\n    width: '100%',\n    height: 50,\n    marginBottom: 10\n  }\n});\nconst Player = ({\n  audioSrc,\n  segments,\n  keywords\n}) => {\n  _s();\n  const classes = useStyles();\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [hoveredKeyword, setHoveredKeyword] = useState(null);\n  const audioRef = useRef(null);\n  const canvasRef1 = useRef(null);\n  const canvasRef2 = useRef(null);\n  useEffect(() => {\n    if (audioRef.current) {\n      audioRef.current.addEventListener('loadedmetadata', () => {\n        setDuration(audioRef.current.duration);\n      });\n      audioRef.current.addEventListener('timeupdate', () => {\n        setCurrentTime(audioRef.current.currentTime);\n      });\n    }\n  }, []);\n  useEffect(() => {\n    drawWaveform();\n  }, [segments, keywords, duration]);\n  const togglePlay = () => {\n    if (audioRef.current) {\n      if (isPlaying) {\n        audioRef.current.pause();\n      } else {\n        audioRef.current.play();\n      }\n      setIsPlaying(!isPlaying);\n    }\n  };\n  const handleSliderChange = (event, newValue) => {\n    if (audioRef.current && typeof newValue === 'number') {\n      audioRef.current.currentTime = newValue;\n      setCurrentTime(newValue);\n    }\n  };\n  const drawWaveform = () => {\n    if (canvasRef1.current && canvasRef2.current && duration > 0) {\n      const drawChannel = (ctx, channelSegments, channelKeywords) => {\n        const canvasWidth = ctx.canvas.width;\n        const canvasHeight = ctx.canvas.height;\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n        // Draw segments\n        channelSegments.forEach(segment => {\n          const startX = segment.Start / duration * canvasWidth;\n          const endX = segment.End / duration * canvasWidth;\n          ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\" ? \"rgba(181, 201, 255, 0.5)\" : \"rgba(0, 123, 255, 0.5)\";\n          ctx.fillRect(startX, 0, endX - startX, canvasHeight);\n        });\n\n        // Draw keywords\n        channelKeywords.forEach(kw => {\n          const startX = kw.keyword.Start / duration * canvasWidth;\n          const width = 2;\n          ctx.fillStyle = kw.color;\n          ctx.fillRect(startX, 0, width, canvasHeight);\n        });\n      };\n      const ctx1 = canvasRef1.current.getContext('2d');\n      const ctx2 = canvasRef2.current.getContext('2d');\n      if (ctx1 && ctx2) {\n        const channel1Segments = segments.filter(s => s.ChannelNumber === 1);\n        const channel2Segments = segments.filter(s => s.ChannelNumber === 2);\n        const channel1Keywords = keywords.filter(k => k.keyword.ChannelNumber === 1);\n        const channel2Keywords = keywords.filter(k => k.keyword.ChannelNumber === 2);\n        drawChannel(ctx1, channel1Segments, channel1Keywords);\n        drawChannel(ctx2, channel2Segments, channel2Keywords);\n\n        // Draw current time indicator\n        const currentTimeX = currentTime / duration * ctx1.canvas.width;\n        [ctx1, ctx2].forEach(ctx => {\n          ctx.strokeStyle = 'red';\n          ctx.lineWidth = 2;\n          ctx.beginPath();\n          ctx.moveTo(currentTimeX, 0);\n          ctx.lineTo(currentTimeX, ctx.canvas.height);\n          ctx.stroke();\n        });\n      }\n    }\n  };\n  const handleCanvasMouseMove = (event, channelKeywords) => {\n    const canvas = event.currentTarget;\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const time = x / canvas.width * duration;\n    const hoveredKw = channelKeywords.find(kw => time >= kw.keyword.Start && time <= kw.keyword.End);\n    setHoveredKeyword(hoveredKw || null);\n  };\n  const handleCanvasMouseLeave = () => {\n    setHoveredKeyword(null);\n  };\n  const formatTime = time => {\n    const minutes = Math.floor(time / 60);\n    const seconds = Math.floor(time % 60);\n    return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: classes.root,\n    children: [/*#__PURE__*/_jsxDEV(\"audio\", {\n      ref: audioRef,\n      src: audioSrc\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 362,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: classes.canvasContainer,\n      children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef1,\n        className: classes.canvas,\n        width: 1000,\n        height: 50,\n        onMouseMove: e => handleCanvasMouseMove(e, keywords.filter(k => k.keyword.ChannelNumber === 1)),\n        onMouseLeave: handleCanvasMouseLeave\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 364,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: classes.controls,\n        children: [/*#__PURE__*/_jsxDEV(IconButton, {\n          onClick: togglePlay,\n          children: isPlaying ? /*#__PURE__*/_jsxDEV(Pause, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 374,\n            columnNumber: 26\n          }, this) : /*#__PURE__*/_jsxDEV(PlayArrow, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 374,\n            columnNumber: 38\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 373,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Slider, {\n          value: currentTime,\n          onChange: handleSliderChange,\n          min: 0,\n          max: duration,\n          step: 0.1\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 376,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: [formatTime(currentTime), \" / \", formatTime(duration)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 383,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 372,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef2,\n        className: classes.canvas,\n        width: 1000,\n        height: 50,\n        onMouseMove: e => handleCanvasMouseMove(e, keywords.filter(k => k.keyword.ChannelNumber === 2)),\n        onMouseLeave: handleCanvasMouseLeave\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 385,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 363,\n      columnNumber: 7\n    }, this), hoveredKeyword && /*#__PURE__*/_jsxDEV(Tooltip, {\n      title: `${hoveredKeyword.keyword.Name} (${formatTime(hoveredKeyword.keyword.Start)} - ${formatTime(hoveredKeyword.keyword.End)})`,\n      open: true,\n      placement: \"top\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          left: -1000,\n          top: -1000\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 400,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 395,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 361,\n    columnNumber: 5\n  }, this);\n};\n_s(Player, \"+xGknBNk8A32xWwYmO5aLYVUHAI=\", false, function () {\n  return [useStyles];\n});\n_c = Player;\nexport default Player;\nvar _c;\n$RefreshReg$(_c, \"Player\");","map":{"version":3,"names":["React","useState","useRef","useEffect","makeStyles","IconButton","Slider","Tooltip","PlayArrow","Pause","jsxDEV","_jsxDEV","useStyles","root","width","display","flexDirection","alignItems","controls","margin","canvasContainer","canvas","height","marginBottom","Player","audioSrc","segments","keywords","_s","classes","isPlaying","setIsPlaying","currentTime","setCurrentTime","duration","setDuration","hoveredKeyword","setHoveredKeyword","audioRef","canvasRef1","canvasRef2","current","addEventListener","drawWaveform","togglePlay","pause","play","handleSliderChange","event","newValue","drawChannel","ctx","channelSegments","channelKeywords","canvasWidth","canvasHeight","clearRect","forEach","segment","startX","Start","endX","End","fillStyle","Words","NormalForm","fillRect","kw","keyword","color","ctx1","getContext","ctx2","channel1Segments","filter","s","ChannelNumber","channel2Segments","channel1Keywords","k","channel2Keywords","currentTimeX","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","handleCanvasMouseMove","currentTarget","rect","getBoundingClientRect","x","clientX","left","time","hoveredKw","find","handleCanvasMouseLeave","formatTime","minutes","Math","floor","seconds","className","children","ref","src","fileName","_jsxFileName","lineNumber","columnNumber","onMouseMove","e","onMouseLeave","onClick","value","onChange","min","max","step","title","Name","open","placement","style","position","top","_c","$RefreshReg$"],"sources":["/home/gleb/my_app_test/src/audio/r6/Player.tsx"],"sourcesContent":["// import React, { useState, useRef, useEffect } from 'react';\n// import { makeStyles } from '@material-ui/core/styles';\n// import { IconButton, Slider } from '@material-ui/core';\n// import { PlayArrow, Pause } from '@material-ui/icons';\n\n// interface PlayerProps {\n//   audioSrc: string;\n//   segments: SegmentModel[];\n//   keywords: KeywordColor[];\n// }\n\n// interface SegmentModel {\n//   Start: number;\n//   End: number;\n//   ChannelNumber: number;\n//   Words?: { NormalForm: string }[];\n// }\n\n// interface KeywordColor {\n//   keyword: {\n//     Start: number;\n//     End: number;\n//     Name: string;\n//     ChannelNumber: number;\n//     Confidence: number;\n//   };\n//   color: string;\n// }\n\n// const useStyles = makeStyles({\n//   root: {\n//     width: '100%',\n//     display: 'flex',\n//     flexDirection: 'column',\n//     alignItems: 'center',\n//   },\n//   controls: {\n//     display: 'flex',\n//     alignItems: 'center',\n//     width: '100%',\n//     marginBottom: 20,\n//     marginTop: 100,\n//   },\n//   canvas: {\n//     width: '100%',\n//     height: 100,\n//     border: '1px solid black', // Added for visibility\n//   },\n// });\n\n// const Player: React.FC<PlayerProps> = ({ audioSrc, segments, keywords }) => {\n//   const classes = useStyles();\n//   const [isPlaying, setIsPlaying] = useState(false);\n//   const [currentTime, setCurrentTime] = useState(0);\n//   const [duration, setDuration] = useState(0);\n  \n//   const audioRef = useRef<HTMLAudioElement>(null);\n//   const canvasRef = useRef<HTMLCanvasElement>(null);\n\n//   useEffect(() => {\n//     if (audioRef.current) {\n//       audioRef.current.addEventListener('loadedmetadata', () => {\n//         setDuration(audioRef.current!.duration);\n//       });\n//       audioRef.current.addEventListener('timeupdate', () => {\n//         setCurrentTime(audioRef.current!.currentTime);\n//       });\n//     }\n//   }, []);\n\n//   useEffect(() => {\n//     drawWaveform();\n//   }, [segments, keywords, duration]);\n\n//   const togglePlay = () => {\n//     if (audioRef.current) {\n//       if (isPlaying) {\n//         audioRef.current.pause();\n//       } else {\n//         audioRef.current.play();\n//       }\n//       setIsPlaying(!isPlaying);\n//     }\n//   };\n\n//   const handleSliderChange = (event: any, newValue: number | number[]) => {\n//     if (audioRef.current && typeof newValue === 'number') {\n//       audioRef.current.currentTime = newValue;\n//       setCurrentTime(newValue);\n//     }\n//   };\n\n//   const drawWaveform = () => {\n//     if (canvasRef.current && duration > 0) {\n//       const ctx = canvasRef.current.getContext('2d');\n//       if (ctx) {\n//         const canvasWidth = canvasRef.current.width;\n//         const canvasHeight = canvasRef.current.height;\n\n//         ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        \n//         console.log(`Drawing ${segments.length} segments and ${keywords.length} keywords`);\n        \n//         // Draw segments\n//         segments.forEach((segment, index) => {\n//             const startX = (segment.Start / duration) * canvasWidth;\n//             const endX = (segment.End / duration) * canvasWidth;\n//             ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\"\n//               ? \"rgba(181, 201, 255, 0.5)\"\n//               : \"rgba(0, 123, 255, 0.5)\";\n//             ctx.fillRect(startX, 0, endX - startX, canvasHeight);\n//             console.log(`Drawing segment ${index}: start=${startX}, end=${endX}, color=${ctx.fillStyle}`);\n//           });\n  \n//           // Draw keywords\n//           keywords.forEach((kw, index) => {\n//             const startX = (kw.keyword.Start / duration) * canvasWidth;\n//             const width = ((kw.keyword.End - kw.keyword.Start) / duration) * canvasWidth;\n//             ctx.fillStyle = kw.color;\n//             ctx.fillRect(startX, 0, width, canvasHeight / 4);\n//             console.log(`Drawing keyword ${index}: start=${startX}, width=${width}, color=${kw.color}`);\n//           });\n  \n//           // Draw current time indicator\n//           const currentTimeX = (currentTime / duration) * canvasWidth;\n//           ctx.strokeStyle = 'red';\n//           ctx.lineWidth = 2;\n//           ctx.beginPath();\n//           ctx.moveTo(currentTimeX, 0);\n//           ctx.lineTo(currentTimeX, canvasHeight);\n//           ctx.stroke();\n//         }\n//       } else {\n//         console.log('Canvas not ready or duration is 0');\n//       }\n//     };\n  \n//     const formatTime = (time: number) => {\n//       const minutes = Math.floor(time / 60);\n//       const seconds = Math.floor(time % 60);\n//       return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n//     };\n  \n//     return (\n//       <div className={classes.root}>\n//         <audio ref={audioRef} src={audioSrc} />\n//         <div className={classes.controls}>\n//           <IconButton onClick={togglePlay}>\n//             {isPlaying ? <Pause /> : <PlayArrow />}\n//           </IconButton>\n//           <Slider\n//             value={currentTime}\n//             onChange={handleSliderChange}\n//             min={0}\n//             max={duration}\n//             step={0.1}\n//           />\n//           <span>{formatTime(currentTime)} / {formatTime(duration)}</span>\n//         </div>\n//         <canvas \n//           ref={canvasRef} \n//           className={classes.canvas}\n//           width={1000}\n//           height={100}\n//           onClick={(e) => {\n//             const rect = canvasRef.current!.getBoundingClientRect();\n//             const x = e.clientX - rect.left;\n//             const clickTime = (x / canvasRef.current!.width) * duration;\n//             if (audioRef.current) {\n//               audioRef.current.currentTime = clickTime;\n//             }\n//           }}\n//         />\n//         <div>\n//           <p>Segments: {segments.length}</p>\n//           <p>Keywords: {keywords.length}</p>\n//           <p>Duration: {duration}</p>\n//         </div>\n//       </div>\n//     );\n//   };\n  \n//   export default Player;\n\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport { IconButton, Slider, Tooltip } from '@material-ui/core';\nimport { PlayArrow, Pause } from '@material-ui/icons';\n\ninterface PlayerProps {\n  audioSrc: string;\n  segments: SegmentModel[];\n  keywords: KeywordColor[];\n}\n\ninterface SegmentModel {\n  Start: number;\n  End: number;\n  ChannelNumber: number;\n  Words?: { NormalForm: string }[];\n}\n\ninterface KeywordColor {\n  keyword: {\n    Start: number;\n    End: number;\n    Name: string;\n    ChannelNumber: number;\n    Confidence: number;\n  };\n  color: string;\n}\n\nconst useStyles = makeStyles({\n  root: {\n    width: '100%',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n  },\n  controls: {\n    display: 'flex',\n    alignItems: 'center',\n    width: '100%',\n    margin: '20px 0',\n  },\n  canvasContainer: {\n    width: '100%',\n    display: 'flex',\n    flexDirection: 'column',\n  },\n  canvas: {\n    width: '100%',\n    height: 50,\n    marginBottom: 10,\n  },\n});\n\nconst Player: React.FC<PlayerProps> = ({ audioSrc, segments, keywords }) => {\n  const classes = useStyles();\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [hoveredKeyword, setHoveredKeyword] = useState<KeywordColor | null>(null);\n  \n  const audioRef = useRef<HTMLAudioElement>(null);\n  const canvasRef1 = useRef<HTMLCanvasElement>(null);\n  const canvasRef2 = useRef<HTMLCanvasElement>(null);\n\n    useEffect(() => {\n    if (audioRef.current) {\n      audioRef.current.addEventListener('loadedmetadata', () => {\n        setDuration(audioRef.current!.duration);\n      });\n      audioRef.current.addEventListener('timeupdate', () => {\n        setCurrentTime(audioRef.current!.currentTime);\n      });\n    }\n  }, []);\n\n  useEffect(() => {\n    drawWaveform();\n  }, [segments, keywords, duration]);\n\n  const togglePlay = () => {\n    if (audioRef.current) {\n      if (isPlaying) {\n        audioRef.current.pause();\n      } else {\n        audioRef.current.play();\n      }\n      setIsPlaying(!isPlaying);\n    }\n  };\n\n  const handleSliderChange = (event: any, newValue: number | number[]) => {\n    if (audioRef.current && typeof newValue === 'number') {\n      audioRef.current.currentTime = newValue;\n      setCurrentTime(newValue);\n    }\n  };\n\n  const drawWaveform = () => {\n    if (canvasRef1.current && canvasRef2.current && duration > 0) {\n      const drawChannel = (ctx: CanvasRenderingContext2D, channelSegments: SegmentModel[], channelKeywords: KeywordColor[]) => {\n        const canvasWidth = ctx.canvas.width;\n        const canvasHeight = ctx.canvas.height;\n\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        \n        // Draw segments\n        channelSegments.forEach((segment) => {\n          const startX = (segment.Start / duration) * canvasWidth;\n          const endX = (segment.End / duration) * canvasWidth;\n          ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\"\n            ? \"rgba(181, 201, 255, 0.5)\"\n            : \"rgba(0, 123, 255, 0.5)\";\n          ctx.fillRect(startX, 0, endX - startX, canvasHeight);\n        });\n\n        // Draw keywords\n        channelKeywords.forEach((kw) => {\n          const startX = (kw.keyword.Start / duration) * canvasWidth;\n          const width = 2;\n          ctx.fillStyle = kw.color;\n          ctx.fillRect(startX, 0, width, canvasHeight);\n        });\n      };\n\n      const ctx1 = canvasRef1.current.getContext('2d');\n      const ctx2 = canvasRef2.current.getContext('2d');\n\n      if (ctx1 && ctx2) {\n        const channel1Segments = segments.filter(s => s.ChannelNumber === 1);\n        const channel2Segments = segments.filter(s => s.ChannelNumber === 2);\n        const channel1Keywords = keywords.filter(k => k.keyword.ChannelNumber === 1);\n        const channel2Keywords = keywords.filter(k => k.keyword.ChannelNumber === 2);\n\n        drawChannel(ctx1, channel1Segments, channel1Keywords);\n        drawChannel(ctx2, channel2Segments, channel2Keywords);\n\n        // Draw current time indicator\n        const currentTimeX = (currentTime / duration) * ctx1.canvas.width;\n        [ctx1, ctx2].forEach(ctx => {\n          ctx.strokeStyle = 'red';\n          ctx.lineWidth = 2;\n          ctx.beginPath();\n          ctx.moveTo(currentTimeX, 0);\n          ctx.lineTo(currentTimeX, ctx.canvas.height);\n          ctx.stroke();\n        });\n      }\n    }\n  };\n\n  const handleCanvasMouseMove = (event: React.MouseEvent<HTMLCanvasElement>, channelKeywords: KeywordColor[]) => {\n    const canvas = event.currentTarget;\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const time = (x / canvas.width) * duration;\n\n    const hoveredKw = channelKeywords.find(kw => \n      time >= kw.keyword.Start && time <= kw.keyword.End\n    );\n\n    setHoveredKeyword(hoveredKw || null);\n  };\n\n  const handleCanvasMouseLeave = () => {\n    setHoveredKeyword(null);\n  };\n\n  const formatTime = (time: number) => {\n    const minutes = Math.floor(time / 60);\n    const seconds = Math.floor(time % 60);\n    return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n  };\n\n  return (\n    <div className={classes.root}>\n      <audio ref={audioRef} src={audioSrc} />\n      <div className={classes.canvasContainer}>\n        <canvas \n          ref={canvasRef1} \n          className={classes.canvas}\n          width={1000}\n          height={50}\n          onMouseMove={(e) => handleCanvasMouseMove(e, keywords.filter(k => k.keyword.ChannelNumber === 1))}\n          onMouseLeave={handleCanvasMouseLeave}\n        />\n        <div className={classes.controls}>\n          <IconButton onClick={togglePlay}>\n            {isPlaying ? <Pause /> : <PlayArrow />}\n          </IconButton>\n          <Slider\n            value={currentTime}\n            onChange={handleSliderChange}\n            min={0}\n            max={duration}\n            step={0.1}\n          />\n          <span>{formatTime(currentTime)} / {formatTime(duration)}</span>\n        </div>\n        <canvas \n          ref={canvasRef2} \n          className={classes.canvas}\n          width={1000}\n          height={50}\n          onMouseMove={(e) => handleCanvasMouseMove(e, keywords.filter(k => k.keyword.ChannelNumber === 2))}\n          onMouseLeave={handleCanvasMouseLeave}\n        />\n      </div>\n      {hoveredKeyword && (\n        <Tooltip\n          title={`${hoveredKeyword.keyword.Name} (${formatTime(hoveredKeyword.keyword.Start)} - ${formatTime(hoveredKeyword.keyword.End)})`}\n          open={true}\n          placement=\"top\"\n        >\n          <div style={{ position: 'absolute', left: -1000, top: -1000 }}></div>\n        </Tooltip>\n      )}\n    </div>\n  );\n};\n\nexport default Player;"],"mappings":";;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,MAAM,EAAEC,SAAS,QAAQ,OAAO;AAC1D,SAASC,UAAU,QAAQ,0BAA0B;AACrD,SAASC,UAAU,EAAEC,MAAM,EAAEC,OAAO,QAAQ,mBAAmB;AAC/D,SAASC,SAAS,EAAEC,KAAK,QAAQ,oBAAoB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AA0BtD,MAAMC,SAAS,GAAGR,UAAU,CAAC;EAC3BS,IAAI,EAAE;IACJC,KAAK,EAAE,MAAM;IACbC,OAAO,EAAE,MAAM;IACfC,aAAa,EAAE,QAAQ;IACvBC,UAAU,EAAE;EACd,CAAC;EACDC,QAAQ,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}