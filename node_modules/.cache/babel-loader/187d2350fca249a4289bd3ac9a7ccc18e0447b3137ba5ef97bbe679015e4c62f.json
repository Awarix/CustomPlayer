{"ast":null,"code":"/*!\n * wavesurfer.js timeline plugin 6.6.4 (2023-06-10)\n * https://wavesurfer-js.org\n * @license BSD-3-Clause\n */\n!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define(\"WaveSurfer\", [], t) : \"object\" == typeof exports ? exports.WaveSurfer = t() : (e.WaveSurfer = e.WaveSurfer || {}, e.WaveSurfer.timeline = t());\n}(self, () => (() => {\n  \"use strict\";\n\n  var e = {\n      171: (e, t) => {\n        function a(e) {\n          return a = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n            return typeof e;\n          } : function (e) {\n            return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n          }, a(e);\n        }\n        function r(e, t) {\n          for (var a = 0; a < t.length; a++) {\n            var r = t[a];\n            r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, n(r.key), r);\n          }\n        }\n        function i(e, t, a) {\n          return (t = n(t)) in e ? Object.defineProperty(e, t, {\n            value: a,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n          }) : e[t] = a, e;\n        }\n        function n(e) {\n          var t = function (e, t) {\n            if (\"object\" !== a(e) || null === e) return e;\n            var r = e[Symbol.toPrimitive];\n            if (void 0 !== r) {\n              var i = r.call(e, t || \"default\");\n              if (\"object\" !== a(i)) return i;\n              throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n            }\n            return (\"string\" === t ? String : Number)(e);\n          }(e, \"string\");\n          return \"symbol\" === a(t) ? t : String(t);\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0;\n        var o = function () {\n          function e(t, a) {\n            var r = this;\n            if (function (e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }(this, e), i(this, \"_onScroll\", function () {\n              r.wrapper && r.drawer.wrapper && (r.wrapper.scrollLeft = r.drawer.wrapper.scrollLeft);\n            }), i(this, \"_onRedraw\", function () {\n              return r.render();\n            }), i(this, \"_onReady\", function () {\n              var e = r.wavesurfer;\n              r.drawer = e.drawer, r.pixelRatio = e.drawer.params.pixelRatio, r.maxCanvasWidth = e.drawer.maxCanvasWidth || e.drawer.width, r.maxCanvasElementWidth = e.drawer.maxCanvasElementWidth || Math.round(r.maxCanvasWidth / r.pixelRatio), e.drawer.wrapper.addEventListener(\"scroll\", r._onScroll), e.on(\"redraw\", r._onRedraw), e.on(\"zoom\", r._onZoom), r.render();\n            }), i(this, \"_onWrapperClick\", function (e) {\n              e.preventDefault();\n              var t = \"offsetX\" in e ? e.offsetX : e.layerX;\n              r.fireEvent(\"click\", t / r.wrapper.scrollWidth || 0);\n            }), this.container = \"string\" == typeof t.container ? document.querySelector(t.container) : t.container, !this.container) throw new Error(\"No container for wavesurfer timeline\");\n            this.wavesurfer = a, this.util = a.util, this.params = Object.assign({}, {\n              height: 20,\n              notchPercentHeight: 90,\n              labelPadding: 5,\n              unlabeledNotchColor: \"#c0c0c0\",\n              primaryColor: \"#000\",\n              secondaryColor: \"#c0c0c0\",\n              primaryFontColor: \"#000\",\n              secondaryFontColor: \"#000\",\n              fontFamily: \"Arial\",\n              fontSize: 10,\n              duration: null,\n              zoomDebounce: !1,\n              formatTimeCallback: this.defaultFormatTimeCallback,\n              timeInterval: this.defaultTimeInterval,\n              primaryLabelInterval: this.defaultPrimaryLabelInterval,\n              secondaryLabelInterval: this.defaultSecondaryLabelInterval,\n              offset: 0\n            }, t), this.canvases = [], this.wrapper = null, this.drawer = null, this.pixelRatio = null, this.maxCanvasWidth = null, this.maxCanvasElementWidth = null, this._onZoom = this.params.zoomDebounce ? this.wavesurfer.util.debounce(function () {\n              return r.render();\n            }, this.params.zoomDebounce) : function () {\n              return r.render();\n            };\n          }\n          var t, a, n;\n          return t = e, n = [{\n            key: \"create\",\n            value: function (t) {\n              return {\n                name: \"timeline\",\n                deferInit: !(!t || !t.deferInit) && t.deferInit,\n                params: t,\n                instance: e\n              };\n            }\n          }], (a = [{\n            key: \"init\",\n            value: function () {\n              this.wavesurfer.isReady ? this._onReady() : this.wavesurfer.once(\"ready\", this._onReady);\n            }\n          }, {\n            key: \"destroy\",\n            value: function () {\n              this.unAll(), this.wavesurfer.un(\"redraw\", this._onRedraw), this.wavesurfer.un(\"zoom\", this._onZoom), this.wavesurfer.un(\"ready\", this._onReady), this.wavesurfer.drawer.wrapper.removeEventListener(\"scroll\", this._onScroll), this.wrapper && this.wrapper.parentNode && (this.wrapper.removeEventListener(\"click\", this._onWrapperClick), this.wrapper.parentNode.removeChild(this.wrapper), this.wrapper = null);\n            }\n          }, {\n            key: \"createWrapper\",\n            value: function () {\n              var e = this.wavesurfer.params;\n              this.container.innerHTML = \"\", this.wrapper = this.container.appendChild(document.createElement(\"timeline\")), this.util.style(this.wrapper, {\n                display: \"block\",\n                position: \"relative\",\n                userSelect: \"none\",\n                webkitUserSelect: \"none\",\n                height: \"\".concat(this.params.height, \"px\")\n              }), (e.fillParent || e.scrollParent) && this.util.style(this.wrapper, {\n                width: \"100%\",\n                overflowX: \"hidden\",\n                overflowY: \"hidden\"\n              }), this.wrapper.addEventListener(\"click\", this._onWrapperClick);\n            }\n          }, {\n            key: \"render\",\n            value: function () {\n              this.wrapper || this.createWrapper(), this.updateCanvases(), this.updateCanvasesPositioning(), this.renderCanvases();\n            }\n          }, {\n            key: \"addCanvas\",\n            value: function () {\n              var e = this.wrapper.appendChild(document.createElement(\"canvas\"));\n              this.canvases.push(e), this.util.style(e, {\n                position: \"absolute\",\n                zIndex: 4\n              });\n            }\n          }, {\n            key: \"removeCanvas\",\n            value: function () {\n              var e = this.canvases.pop();\n              e.parentElement.removeChild(e);\n            }\n          }, {\n            key: \"updateCanvases\",\n            value: function () {\n              for (var e = Math.round(this.drawer.wrapper.scrollWidth), t = Math.ceil(e / this.maxCanvasElementWidth); this.canvases.length < t;) this.addCanvas();\n              for (; this.canvases.length > t;) this.removeCanvas();\n            }\n          }, {\n            key: \"updateCanvasesPositioning\",\n            value: function () {\n              var e = this,\n                t = this.canvases.length;\n              this.canvases.forEach(function (a, r) {\n                var i = r === t - 1 ? e.drawer.wrapper.scrollWidth - e.maxCanvasElementWidth * (t - 1) : e.maxCanvasElementWidth;\n                a.width = i * e.pixelRatio, a.height = (e.params.height + 1) * e.pixelRatio, e.util.style(a, {\n                  width: \"\".concat(i, \"px\"),\n                  height: \"\".concat(e.params.height, \"px\"),\n                  left: \"\".concat(r * e.maxCanvasElementWidth, \"px\")\n                });\n              });\n            }\n          }, {\n            key: \"renderCanvases\",\n            value: function () {\n              var e = this,\n                t = this.params.duration || this.wavesurfer.backend.getDuration();\n              if (!(t <= 0)) {\n                var a,\n                  r = this.wavesurfer.params,\n                  i = this.params.fontSize * r.pixelRatio,\n                  n = parseInt(t, 10) + 1,\n                  o = r.fillParent && !r.scrollParent ? this.drawer.getWidth() : this.drawer.wrapper.scrollWidth * r.pixelRatio,\n                  s = this.params.height * this.pixelRatio,\n                  l = this.params.height * (this.params.notchPercentHeight / 100) * this.pixelRatio,\n                  c = o / t,\n                  h = this.params.formatTimeCallback,\n                  u = function (e) {\n                    return \"function\" == typeof e ? e(c) : e;\n                  },\n                  f = u(this.params.timeInterval),\n                  p = u(this.params.primaryLabelInterval),\n                  d = u(this.params.secondaryLabelInterval),\n                  v = c * this.params.offset,\n                  m = 0,\n                  y = [],\n                  w = this.params.offset < 0 ? n - this.params.offset : n;\n                for (a = 0; a < w / f; a++) y.push([a, m, v]), m += f, v += c * f;\n                var x = function (e) {\n                  y.forEach(function (t) {\n                    e(t[0], t[1], t[2]);\n                  });\n                };\n                this.setFillStyles(this.params.primaryColor), this.setFonts(\"\".concat(i, \"px \").concat(this.params.fontFamily)), this.setFillStyles(this.params.primaryFontColor), x(function (t, a, r) {\n                  t % p == 0 && (e.fillRect(r, 0, 1, s), e.fillText(h(a, c), r + e.params.labelPadding * e.pixelRatio, s));\n                }), this.setFillStyles(this.params.secondaryColor), this.setFonts(\"\".concat(i, \"px \").concat(this.params.fontFamily)), this.setFillStyles(this.params.secondaryFontColor), x(function (t, a, r) {\n                  t % d == 0 && (e.fillRect(r, 0, 1, s), e.fillText(h(a, c), r + e.params.labelPadding * e.pixelRatio, s));\n                }), this.setFillStyles(this.params.unlabeledNotchColor), x(function (t, a, r) {\n                  t % d != 0 && t % p != 0 && e.fillRect(r, 0, 1, l);\n                });\n              }\n            }\n          }, {\n            key: \"setFillStyles\",\n            value: function (e) {\n              this.canvases.forEach(function (t) {\n                var a = t.getContext(\"2d\");\n                a && (a.fillStyle = e);\n              });\n            }\n          }, {\n            key: \"setFonts\",\n            value: function (e) {\n              this.canvases.forEach(function (t) {\n                var a = t.getContext(\"2d\");\n                a && (a.font = e);\n              });\n            }\n          }, {\n            key: \"fillRect\",\n            value: function (e, t, a, r) {\n              var i = this;\n              this.canvases.forEach(function (n, o) {\n                var s = o * i.maxCanvasWidth,\n                  l = {\n                    x1: Math.max(e, o * i.maxCanvasWidth),\n                    y1: t,\n                    x2: Math.min(e + a, o * i.maxCanvasWidth + n.width),\n                    y2: t + r\n                  };\n                if (l.x1 < l.x2) {\n                  var c = n.getContext(\"2d\");\n                  c && c.fillRect(l.x1 - s, l.y1, l.x2 - l.x1, l.y2 - l.y1);\n                }\n              });\n            }\n          }, {\n            key: \"fillText\",\n            value: function (e, t, a) {\n              var r,\n                i = 0;\n              this.canvases.forEach(function (n) {\n                var o = n.getContext(\"2d\");\n                if (o) {\n                  var s = o.canvas.width;\n                  if (i > t + r) return;\n                  i + s > t && o && (r = o.measureText(e).width, o.fillText(e, t - i, a)), i += s;\n                }\n              });\n            }\n          }, {\n            key: \"defaultFormatTimeCallback\",\n            value: function (e, t) {\n              if (e / 60 > 1) {\n                var a = parseInt(e / 60, 10);\n                return e = (e = parseInt(e % 60, 10)) < 10 ? \"0\" + e : e, \"\".concat(a, \":\").concat(e);\n              }\n              return Math.round(1e3 * e) / 1e3;\n            }\n          }, {\n            key: \"defaultTimeInterval\",\n            value: function (e) {\n              return e >= 25 ? 1 : 5 * e >= 25 ? 5 : 15 * e >= 25 ? 15 : 60 * Math.ceil(.5 / e);\n            }\n          }, {\n            key: \"defaultPrimaryLabelInterval\",\n            value: function (e) {\n              return e >= 25 ? 10 : 5 * e >= 25 ? 6 : 4;\n            }\n          }, {\n            key: \"defaultSecondaryLabelInterval\",\n            value: function (e) {\n              return e >= 25 ? 5 : 2;\n            }\n          }]) && r(t.prototype, a), n && r(t, n), Object.defineProperty(t, \"prototype\", {\n            writable: !1\n          }), e;\n        }();\n        t.default = o, e.exports = t.default;\n      }\n    },\n    t = {};\n  var a = function a(r) {\n    var i = t[r];\n    if (void 0 !== i) return i.exports;\n    var n = t[r] = {\n      exports: {}\n    };\n    return e[r](n, n.exports, a), n.exports;\n  }(171);\n  return a;\n})());","map":{"version":3,"names":["e","t","exports","module","define","amd","WaveSurfer","timeline","self","o","a","r","i","wrapper","drawer","scrollLeft","render","wavesurfer","pixelRatio","params","maxCanvasWidth","width","maxCanvasElementWidth","Math","round","addEventListener","_onScroll","on","_onRedraw","_onZoom","preventDefault","offsetX","layerX","fireEvent","scrollWidth","container","document","querySelector","Error","util","Object","assign","height","notchPercentHeight","labelPadding","unlabeledNotchColor","primaryColor","secondaryColor","primaryFontColor","secondaryFontColor","fontFamily","fontSize","duration","zoomDebounce","formatTimeCallback","defaultFormatTimeCallback","timeInterval","defaultTimeInterval","primaryLabelInterval","defaultPrimaryLabelInterval","secondaryLabelInterval","defaultSecondaryLabelInterval","offset","canvases","debounce","key","value","name","deferInit","instance","isReady","_onReady","once","unAll","un","removeEventListener","parentNode","_onWrapperClick","removeChild","innerHTML","appendChild","createElement","style","display","position","userSelect","webkitUserSelect","concat","fillParent","scrollParent","overflowX","overflowY","createWrapper","updateCanvases","updateCanvasesPositioning","renderCanvases","push","zIndex","pop","parentElement","ceil","length","addCanvas","removeCanvas","forEach","left","backend","getDuration","n","parseInt","getWidth","s","l","c","h","u","intervalFnOrVal","f","p","d","v","m","y","w","x","renderPositions","setFillStyles","setFonts","fillRect","fillText","getContext","fillStyle","font","x1","max","y1","x2","min","y2","canvas","measureText","default"],"sources":["webpack://WaveSurfer/webpack/universalModuleDefinition","webpack://WaveSurfer/src/plugin/timeline/index.js","webpack://WaveSurfer/webpack/bootstrap","webpack://WaveSurfer/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WaveSurfer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WaveSurfer\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"timeline\"] = factory();\n})(self, () => {\nreturn ","/**\n * @typedef {Object} TimelinePluginParams\n * @desc Extends the `WavesurferParams` wavesurfer was initialised with\n * @property {!string|HTMLElement} container CSS selector or HTML element where\n * the timeline should be drawn. This is the only required parameter.\n * @property {number} notchPercentHeight=90 Height of notches in percent\n * @property {string} unlabeledNotchColor='#c0c0c0' The colour of the notches\n * that do not have labels\n * @property {string} primaryColor='#000' The colour of the main notches\n * @property {string} secondaryColor='#c0c0c0' The colour of the secondary\n * notches\n * @property {string} primaryFontColor='#000' The colour of the labels next to\n * the main notches\n * @property {string} secondaryFontColor='#000' The colour of the labels next to\n * the secondary notches\n * @property {number} labelPadding=5 The padding between the label and the notch\n * @property {?number} zoomDebounce A debounce timeout to increase rendering\n * performance for large files\n * @property {string} fontFamily='Arial'\n * @property {number} fontSize=10 Font size of labels in pixels\n * @property {?number} duration Length of the track in seconds. Overrides\n * getDuration() for setting length of timeline\n * @property {function} formatTimeCallback (sec, pxPerSec) -> label\n * @property {function} timeInterval (pxPerSec) -> seconds between notches\n * @property {function} primaryLabelInterval (pxPerSec) -> cadence between\n * labels in primary color\n * @property {function} secondaryLabelInterval (pxPerSec) -> cadence between\n * labels in secondary color\n * @property {?number} offset Offset for the timeline start in seconds. May also be\n * negative.\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('timeline')`\n */\n\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wavesurfer.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wavesurfer.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nexport default class TimelinePlugin {\n    /**\n     * Timeline plugin definition factory\n     *\n     * This function must be used to create a plugin definition which can be\n     * used by wavesurfer to correctly instantiate the plugin.\n     *\n     * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n     * @return {PluginDefinition} an object representing the plugin\n     */\n    static create(params) {\n        return {\n            name: 'timeline',\n            deferInit: params && params.deferInit ? params.deferInit : false,\n            params: params,\n            instance: TimelinePlugin\n        };\n    }\n\n    // event handlers\n    _onScroll = () => {\n        if (this.wrapper && this.drawer.wrapper) {\n            this.wrapper.scrollLeft = this.drawer.wrapper.scrollLeft;\n        }\n    };\n\n    /**\n     * @returns {void}\n     */\n    _onRedraw = () => this.render();\n\n    _onReady = () => {\n        const ws = this.wavesurfer;\n        this.drawer = ws.drawer;\n        this.pixelRatio = ws.drawer.params.pixelRatio;\n        this.maxCanvasWidth = ws.drawer.maxCanvasWidth || ws.drawer.width;\n        this.maxCanvasElementWidth =\n            ws.drawer.maxCanvasElementWidth ||\n            Math.round(this.maxCanvasWidth / this.pixelRatio);\n\n        // add listeners\n        ws.drawer.wrapper.addEventListener('scroll', this._onScroll);\n        ws.on('redraw', this._onRedraw);\n        ws.on('zoom', this._onZoom);\n\n        this.render();\n    };\n\n    /**\n     * @param {object} e Click event\n     */\n    _onWrapperClick = e => {\n        e.preventDefault();\n        const relX = 'offsetX' in e ? e.offsetX : e.layerX;\n        this.fireEvent('click', relX / this.wrapper.scrollWidth || 0);\n    };\n\n    /**\n     * Creates an instance of TimelinePlugin.\n     *\n     * You probably want to use TimelinePlugin.create()\n     *\n     * @param {TimelinePluginParams} params Plugin parameters\n     * @param {object} ws Wavesurfer instance\n     */\n    constructor(params, ws) {\n        this.container =\n            'string' == typeof params.container\n                ? document.querySelector(params.container)\n                : params.container;\n\n        if (!this.container) {\n            throw new Error('No container for wavesurfer timeline');\n        }\n\n        this.wavesurfer = ws;\n        this.util = ws.util;\n        this.params = Object.assign(\n            {},\n            {\n                height: 20,\n                notchPercentHeight: 90,\n                labelPadding: 5,\n                unlabeledNotchColor: '#c0c0c0',\n                primaryColor: '#000',\n                secondaryColor: '#c0c0c0',\n                primaryFontColor: '#000',\n                secondaryFontColor: '#000',\n                fontFamily: 'Arial',\n                fontSize: 10,\n                duration: null,\n                zoomDebounce: false,\n                formatTimeCallback: this.defaultFormatTimeCallback,\n                timeInterval: this.defaultTimeInterval,\n                primaryLabelInterval: this.defaultPrimaryLabelInterval,\n                secondaryLabelInterval: this.defaultSecondaryLabelInterval,\n                offset: 0\n            },\n            params\n        );\n\n        this.canvases = [];\n        this.wrapper = null;\n        this.drawer = null;\n        this.pixelRatio = null;\n        this.maxCanvasWidth = null;\n        this.maxCanvasElementWidth = null;\n        /**\n         * This event handler has to be in the constructor function because it\n         * relies on the debounce function which is only available after\n         * instantiation\n         *\n         * Use a debounced function if `params.zoomDebounce` is defined\n         *\n         * @returns {void}\n         */\n        this._onZoom = this.params.zoomDebounce\n            ? this.wavesurfer.util.debounce(\n                () => this.render(),\n                this.params.zoomDebounce\n            )\n            : () => this.render();\n    }\n\n    /**\n     * Initialisation function used by the plugin API\n     */\n    init() {\n        // Check if ws is ready\n        if (this.wavesurfer.isReady) {\n            this._onReady();\n        } else {\n            this.wavesurfer.once('ready', this._onReady);\n        }\n    }\n\n    /**\n     * Destroy function used by the plugin API\n     */\n    destroy() {\n        this.unAll();\n        this.wavesurfer.un('redraw', this._onRedraw);\n        this.wavesurfer.un('zoom', this._onZoom);\n        this.wavesurfer.un('ready', this._onReady);\n        this.wavesurfer.drawer.wrapper.removeEventListener(\n            'scroll',\n            this._onScroll\n        );\n        if (this.wrapper && this.wrapper.parentNode) {\n            this.wrapper.removeEventListener('click', this._onWrapperClick);\n            this.wrapper.parentNode.removeChild(this.wrapper);\n            this.wrapper = null;\n        }\n    }\n\n    /**\n     * Create a timeline element to wrap the canvases drawn by this plugin\n     *\n     */\n    createWrapper() {\n        const wsParams = this.wavesurfer.params;\n        this.container.innerHTML = '';\n        this.wrapper = this.container.appendChild(\n            document.createElement('timeline')\n        );\n        this.util.style(this.wrapper, {\n            display: 'block',\n            position: 'relative',\n            userSelect: 'none',\n            webkitUserSelect: 'none',\n            height: `${this.params.height}px`\n        });\n\n        if (wsParams.fillParent || wsParams.scrollParent) {\n            this.util.style(this.wrapper, {\n                width: '100%',\n                overflowX: 'hidden',\n                overflowY: 'hidden'\n            });\n        }\n\n        this.wrapper.addEventListener('click', this._onWrapperClick);\n    }\n\n    /**\n     * Render the timeline (also updates the already rendered timeline)\n     *\n     */\n    render() {\n        if (!this.wrapper) {\n            this.createWrapper();\n        }\n        this.updateCanvases();\n        this.updateCanvasesPositioning();\n        this.renderCanvases();\n    }\n\n    /**\n     * Add new timeline canvas\n     *\n     */\n    addCanvas() {\n        const canvas = this.wrapper.appendChild(\n            document.createElement('canvas')\n        );\n        this.canvases.push(canvas);\n        this.util.style(canvas, {\n            position: 'absolute',\n            zIndex: 4\n        });\n    }\n\n    /**\n     * Remove timeline canvas\n     *\n     */\n    removeCanvas() {\n        const canvas = this.canvases.pop();\n        canvas.parentElement.removeChild(canvas);\n    }\n\n    /**\n     * Make sure the correct of timeline canvas elements exist and are cached in\n     * this.canvases\n     *\n     */\n    updateCanvases() {\n        const totalWidth = Math.round(this.drawer.wrapper.scrollWidth);\n        const requiredCanvases = Math.ceil(\n            totalWidth / this.maxCanvasElementWidth\n        );\n\n        while (this.canvases.length < requiredCanvases) {\n            this.addCanvas();\n        }\n\n        while (this.canvases.length > requiredCanvases) {\n            this.removeCanvas();\n        }\n    }\n\n    /**\n     * Update the dimensions and positioning style for all the timeline canvases\n     *\n     */\n    updateCanvasesPositioning() {\n        // cache length for performance\n        const canvasesLength = this.canvases.length;\n        this.canvases.forEach((canvas, i) => {\n            // canvas width is the max element width, or if it is the last the\n            // required width\n            const canvasWidth =\n                i === canvasesLength - 1\n                    ? this.drawer.wrapper.scrollWidth -\n                      this.maxCanvasElementWidth * (canvasesLength - 1)\n                    : this.maxCanvasElementWidth;\n            // set dimensions and style\n            canvas.width = canvasWidth * this.pixelRatio;\n            // on certain pixel ratios the canvas appears cut off at the bottom,\n            // therefore leave 1px extra\n            canvas.height = (this.params.height + 1) * this.pixelRatio;\n            this.util.style(canvas, {\n                width: `${canvasWidth}px`,\n                height: `${this.params.height}px`,\n                left: `${i * this.maxCanvasElementWidth}px`\n            });\n        });\n    }\n\n    /**\n     * Render the timeline labels and notches\n     *\n     */\n    renderCanvases() {\n        const duration =\n            this.params.duration ||\n            this.wavesurfer.backend.getDuration();\n\n        if (duration <= 0) {\n            return;\n        }\n        const wsParams = this.wavesurfer.params;\n        const fontSize = this.params.fontSize * wsParams.pixelRatio;\n        const totalSeconds = parseInt(duration, 10) + 1;\n        const width =\n            wsParams.fillParent && !wsParams.scrollParent\n                ? this.drawer.getWidth()\n                : this.drawer.wrapper.scrollWidth * wsParams.pixelRatio;\n        const height1 = this.params.height * this.pixelRatio;\n        const height2 =\n            this.params.height *\n            (this.params.notchPercentHeight / 100) *\n            this.pixelRatio;\n        const pixelsPerSecond = width / duration;\n\n        const formatTime = this.params.formatTimeCallback;\n        // if parameter is function, call the function with\n        // pixelsPerSecond, otherwise simply take the value as-is\n        const intervalFnOrVal = option =>\n            typeof option === 'function' ? option(pixelsPerSecond) : option;\n        const timeInterval = intervalFnOrVal(this.params.timeInterval);\n        const primaryLabelInterval = intervalFnOrVal(\n            this.params.primaryLabelInterval\n        );\n        const secondaryLabelInterval = intervalFnOrVal(\n            this.params.secondaryLabelInterval\n        );\n\n        let curPixel = pixelsPerSecond * this.params.offset;\n        let curSeconds = 0;\n        let i;\n        // build an array of position data with index, second and pixel data,\n        // this is then used multiple times below\n        const positioning = [];\n\n        // render until end in case we have a negative offset\n        const renderSeconds = (this.params.offset < 0)\n            ? totalSeconds - this.params.offset\n            : totalSeconds;\n\n        for (i = 0; i < renderSeconds / timeInterval; i++) {\n            positioning.push([i, curSeconds, curPixel]);\n            curSeconds += timeInterval;\n            curPixel += pixelsPerSecond * timeInterval;\n        }\n\n        // iterate over each position\n        const renderPositions = cb => {\n            positioning.forEach(pos => {\n                cb(pos[0], pos[1], pos[2]);\n            });\n        };\n\n        // render primary labels\n        this.setFillStyles(this.params.primaryColor);\n        this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n        this.setFillStyles(this.params.primaryFontColor);\n        renderPositions((i, curSeconds, curPixel) => {\n            if (i % primaryLabelInterval === 0) {\n                this.fillRect(curPixel, 0, 1, height1);\n                this.fillText(\n                    formatTime(curSeconds, pixelsPerSecond),\n                    curPixel + this.params.labelPadding * this.pixelRatio,\n                    height1\n                );\n            }\n        });\n\n        // render secondary labels\n        this.setFillStyles(this.params.secondaryColor);\n        this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n        this.setFillStyles(this.params.secondaryFontColor);\n        renderPositions((i, curSeconds, curPixel) => {\n            if (i % secondaryLabelInterval === 0) {\n                this.fillRect(curPixel, 0, 1, height1);\n                this.fillText(\n                    formatTime(curSeconds, pixelsPerSecond),\n                    curPixel + this.params.labelPadding * this.pixelRatio,\n                    height1\n                );\n            }\n        });\n\n        // render the actual notches (when no labels are used)\n        this.setFillStyles(this.params.unlabeledNotchColor);\n        renderPositions((i, curSeconds, curPixel) => {\n            if (\n                i % secondaryLabelInterval !== 0 &&\n                i % primaryLabelInterval !== 0\n            ) {\n                this.fillRect(curPixel, 0, 1, height2);\n            }\n        });\n    }\n\n    /**\n     * Set the canvas fill style\n     *\n     * @param {DOMString|CanvasGradient|CanvasPattern} fillStyle Fill style to\n     * use\n     */\n    setFillStyles(fillStyle) {\n        this.canvases.forEach(canvas => {\n            const context = canvas.getContext('2d');\n            if (context) {\n                context.fillStyle = fillStyle;\n            }\n        });\n    }\n\n    /**\n     * Set the canvas font\n     *\n     * @param {DOMString} font Font to use\n     */\n    setFonts(font) {\n        this.canvases.forEach(canvas => {\n            const context = canvas.getContext('2d');\n            if (context) {\n                context.font = font;\n            }\n        });\n    }\n\n    /**\n     * Draw a rectangle on the canvases\n     *\n     * (it figures out the offset for each canvas)\n     *\n     * @param {number} x X-position\n     * @param {number} y Y-position\n     * @param {number} width Width\n     * @param {number} height Height\n     */\n    fillRect(x, y, width, height) {\n        this.canvases.forEach((canvas, i) => {\n            const leftOffset = i * this.maxCanvasWidth;\n\n            const intersection = {\n                x1: Math.max(x, i * this.maxCanvasWidth),\n                y1: y,\n                x2: Math.min(x + width, i * this.maxCanvasWidth + canvas.width),\n                y2: y + height\n            };\n\n            if (intersection.x1 < intersection.x2) {\n                const context = canvas\n                    .getContext('2d');\n                if (context) {\n                    context\n                        .fillRect(\n                            intersection.x1 - leftOffset,\n                            intersection.y1,\n                            intersection.x2 - intersection.x1,\n                            intersection.y2 - intersection.y1\n                        );\n                }\n            }\n        });\n    }\n\n    /**\n     * Fill a given text on the canvases\n     *\n     * @param {string} text Text to render\n     * @param {number} x X-position\n     * @param {number} y Y-position\n     */\n    fillText(text, x, y) {\n        let textWidth;\n        let xOffset = 0;\n\n        this.canvases.forEach(canvas => {\n            const context = canvas.getContext('2d');\n            if (context) {\n                const canvasWidth = context.canvas.width;\n\n                if (xOffset > x + textWidth) {\n                    return;\n                }\n\n                if (xOffset + canvasWidth > x && context) {\n                    textWidth = context.measureText(text).width;\n                    context.fillText(text, x - xOffset, y);\n                }\n\n                xOffset += canvasWidth;\n            }\n        });\n    }\n\n    /**\n     * Turn the time into a suitable label for the time.\n     *\n     * @param {number} seconds Seconds to format\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Time\n     */\n    defaultFormatTimeCallback(seconds, pxPerSec) {\n        if (seconds / 60 > 1) {\n            // calculate minutes and seconds from seconds count\n            const minutes = parseInt(seconds / 60, 10);\n            seconds = parseInt(seconds % 60, 10);\n            // fill up seconds with zeroes\n            seconds = seconds < 10 ? '0' + seconds : seconds;\n            return `${minutes}:${seconds}`;\n        }\n        return Math.round(seconds * 1000) / 1000;\n    }\n\n    /**\n     * Return how many seconds should be between each notch\n     *\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Time\n     */\n    defaultTimeInterval(pxPerSec) {\n        if (pxPerSec >= 25) {\n            return 1;\n        } else if (pxPerSec * 5 >= 25) {\n            return 5;\n        } else if (pxPerSec * 15 >= 25) {\n            return 15;\n        }\n        return Math.ceil(0.5 / pxPerSec) * 60;\n    }\n\n    /**\n     * Return the cadence of notches that get labels in the primary color.\n     *\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Cadence\n     */\n    defaultPrimaryLabelInterval(pxPerSec) {\n        if (pxPerSec >= 25) {\n            return 10;\n        } else if (pxPerSec * 5 >= 25) {\n            return 6;\n        } else if (pxPerSec * 15 >= 25) {\n            return 4;\n        }\n        return 4;\n    }\n\n    /**\n     * Return the cadence of notches that get labels in the secondary color.\n     *\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Cadence\n     */\n    defaultSecondaryLabelInterval(pxPerSec) {\n        if (pxPerSec >= 25) {\n            return 5;\n        } else if (pxPerSec * 5 >= 25) {\n            return 2;\n        } else if (pxPerSec * 15 >= 25) {\n            return 2;\n        }\n        return 2;\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(171);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}