{"ast":null,"code":"var _jsxFileName = \"/home/gleb/my_app_test/src/audio/AudioWaveform.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { Tooltip } from '@material-ui/core';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WaveformContainer = styled.div`\n  width: 100%;\n  height: 100px;\n  position: relative;\n  background-color: #f1f3f4;\n  border-radius: 4px;\n  overflow: hidden;\n  cursor: pointer;\n  padding: 30px 0px;\n`;\n_c = WaveformContainer;\nconst WaveformCanvas = styled.canvas`\n  width: 100%;\n  height: 100%;\n  background-color: #f4h2a1;\n`;\n_c2 = WaveformCanvas;\nconst ProgressOverlay = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: ${props => props.progress}%;\n  background-color: rgba(255, 85, 0, 0.2);\n  pointer-events: none;\n`;\n_c3 = ProgressOverlay;\nconst AudioWaveform = ({\n  audioUrl,\n  currentTime,\n  duration,\n  isPlaying,\n  onSeek,\n  onPlayPause,\n  segments,\n  keywords\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const containerRef = useRef(null);\n  const [waveformData, setWaveformData] = useState([]);\n  const [hoveredKeyword, setHoveredKeyword] = useState(null);\n  const [tooltipPosition, setTooltipPosition] = useState({\n    top: 0,\n    left: 0\n  });\n  useEffect(() => {\n    if (audioUrl) {\n      fetchAudioAndComputeWaveform(audioUrl);\n    }\n  }, [audioUrl]);\n  useEffect(() => {\n    drawWaveform();\n  }, [waveformData, currentTime]);\n  const fetchAudioAndComputeWaveform = async url => {\n    try {\n      const response = await fetch(url);\n      const arrayBuffer = await response.arrayBuffer();\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n      const waveform = computeWaveform(audioBuffer);\n      setWaveformData(waveform);\n    } catch (error) {\n      console.error('Error fetching audio:', error);\n    }\n  };\n  const computeWaveform = audioBuffer => {\n    const channelData = audioBuffer.getChannelData(0);\n    const samples = 500;\n    const blockSize = Math.floor(channelData.length / samples);\n    const waveform = [];\n    for (let i = 0; i < samples; i++) {\n      const start = i * blockSize;\n      const end = start + blockSize;\n      let max = 0;\n      for (let j = start; j < end; j++) {\n        const amplitude = Math.abs(channelData[j]);\n        if (amplitude > max) {\n          max = amplitude;\n        }\n      }\n      waveform.push(max);\n    }\n    return waveform;\n  };\n  const drawWaveform = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    const width = canvas.width;\n    const height = canvas.height;\n    const barWidth = width / waveformData.length;\n    ctx.clearRect(0, 0, width, height);\n    waveformData.forEach((value, index) => {\n      const x = index * barWidth;\n      const barHeight = value * height;\n      ctx.fillStyle = currentTime / duration > index / waveformData.length ? '#ff5500' : '#999';\n      ctx.fillRect(x, (height - barHeight) / 2, barWidth - 1, barHeight);\n    });\n\n    // segments.forEach((segment) => {\n    //   const startX = (segment.Start / duration) * width;\n    //   const endX = (segment.End / duration) * width;\n    //   ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\"\n    //     ? \"rgba(181, 201, 255, 0.5)\"\n    //     : \"rgba(0, 123, 255, 0.5)\";\n    //   ctx.fillRect(startX, 0, endX - startX, height);\n    // });\n\n    // Добавьте отрисовку ключевых слов\n    keywords.forEach(kw => {\n      const startX = kw.keyword.Start / duration * width;\n      ctx.fillStyle = kw.color;\n      ctx.fillRect(startX, 0, 2, height);\n    });\n  };\n  const handleClick = e => {\n    if (!containerRef.current) return;\n    const rect = containerRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const seekTime = x / rect.width * duration;\n    onSeek(seekTime);\n  };\n  const handleMouseMove = e => {\n    const rect = containerRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const time = x / rect.width * duration;\n    const hoveredKw = keywords.find(kw => time >= kw.keyword.Start && time <= kw.keyword.End);\n    setHoveredKeyword(hoveredKw || null);\n    setTooltipPosition({\n      top: e.clientY,\n      left: e.clientX\n    });\n  };\n  const handleMouseLeave = () => {\n    setHoveredKeyword(null);\n  };\n  return /*#__PURE__*/_jsxDEV(WaveformContainer, {\n    ref: containerRef,\n    onClick: handleClick,\n    onMouseMove: handleMouseMove,\n    onMouseLeave: handleMouseLeave,\n    children: [/*#__PURE__*/_jsxDEV(WaveformCanvas, {\n      ref: canvasRef,\n      width: 1000,\n      height: 200\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 178,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(ProgressOverlay, {\n      progress: currentTime / duration * 100\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 179,\n      columnNumber: 7\n    }, this), hoveredKeyword && /*#__PURE__*/_jsxDEV(Tooltip, {\n      title: `${hoveredKeyword.keyword.Name} (${formatTime(hoveredKeyword.keyword.Start)} - ${formatTime(hoveredKeyword.keyword.End)})`,\n      open: true,\n      style: {\n        position: 'absolute',\n        top: tooltipPosition.top,\n        left: tooltipPosition.left\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 190,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 181,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 172,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioWaveform, \"1t00S1RhvYyrIjV8hfM147UAno4=\");\n_c4 = AudioWaveform;\nconst formatTime = time => {\n  const minutes = Math.floor(time / 60);\n  const seconds = Math.floor(time % 60);\n  return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n};\nexport default AudioWaveform;\nvar _c, _c2, _c3, _c4;\n$RefreshReg$(_c, \"WaveformContainer\");\n$RefreshReg$(_c2, \"WaveformCanvas\");\n$RefreshReg$(_c3, \"ProgressOverlay\");\n$RefreshReg$(_c4, \"AudioWaveform\");","map":{"version":3,"names":["React","useRef","useEffect","useState","styled","Tooltip","jsxDEV","_jsxDEV","WaveformContainer","div","_c","WaveformCanvas","canvas","_c2","ProgressOverlay","props","progress","_c3","AudioWaveform","audioUrl","currentTime","duration","isPlaying","onSeek","onPlayPause","segments","keywords","_s","canvasRef","containerRef","waveformData","setWaveformData","hoveredKeyword","setHoveredKeyword","tooltipPosition","setTooltipPosition","top","left","fetchAudioAndComputeWaveform","drawWaveform","url","response","fetch","arrayBuffer","audioContext","window","AudioContext","webkitAudioContext","audioBuffer","decodeAudioData","waveform","computeWaveform","error","console","channelData","getChannelData","samples","blockSize","Math","floor","length","i","start","end","max","j","amplitude","abs","push","current","ctx","getContext","width","height","barWidth","clearRect","forEach","value","index","x","barHeight","fillStyle","fillRect","kw","startX","keyword","Start","color","handleClick","e","rect","getBoundingClientRect","clientX","seekTime","handleMouseMove","time","hoveredKw","find","End","clientY","handleMouseLeave","ref","onClick","onMouseMove","onMouseLeave","children","fileName","_jsxFileName","lineNumber","columnNumber","title","Name","formatTime","open","style","position","_c4","minutes","seconds","$RefreshReg$"],"sources":["/home/gleb/my_app_test/src/audio/AudioWaveform.tsx"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { KeywordColor, SegmentModel } from './AudioContext';\nimport { Tooltip } from '@material-ui/core';\n\nconst WaveformContainer = styled.div`\n  width: 100%;\n  height: 100px;\n  position: relative;\n  background-color: #f1f3f4;\n  border-radius: 4px;\n  overflow: hidden;\n  cursor: pointer;\n  padding: 30px 0px;\n`;\n\nconst WaveformCanvas = styled.canvas`\n  width: 100%;\n  height: 100%;\n  background-color: #f4h2a1;\n`;\n\nconst ProgressOverlay = styled.div<{ progress: number }>`\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: ${props => props.progress}%;\n  background-color: rgba(255, 85, 0, 0.2);\n  pointer-events: none;\n`;\n\ninterface AudioWaveformProps {\n  audioUrl: string;\n  currentTime: number;\n  duration: number;\n  isPlaying: boolean;\n  onSeek: (time: number) => void;\n  onPlayPause: () => void;\n  segments: SegmentModel[];\n  keywords: KeywordColor[];\n}\n\nconst AudioWaveform: React.FC<AudioWaveformProps> = ({\n  audioUrl,\n  currentTime,\n  duration,\n  isPlaying,\n  onSeek,\n  onPlayPause,\n  segments,\n  keywords\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [waveformData, setWaveformData] = useState<number[]>([]);\n  const [hoveredKeyword, setHoveredKeyword] = useState<KeywordColor | null>(null);\n  const [tooltipPosition, setTooltipPosition] = useState({ top: 0, left: 0 });\n\n  useEffect(() => {\n    if (audioUrl) {\n      fetchAudioAndComputeWaveform(audioUrl);\n    }\n  }, [audioUrl]);\n\n  useEffect(() => {\n    drawWaveform();\n  }, [waveformData, currentTime]);\n\n  const fetchAudioAndComputeWaveform = async (url: string) => {\n    try {\n      const response = await fetch(url);\n      const arrayBuffer = await response.arrayBuffer();\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n      const waveform = computeWaveform(audioBuffer);\n      setWaveformData(waveform);\n    } catch (error) {\n      console.error('Error fetching audio:', error);\n    }\n  };\n\n  const computeWaveform = (audioBuffer: AudioBuffer) => {\n    const channelData = audioBuffer.getChannelData(0);\n    const samples = 500;\n    const blockSize = Math.floor(channelData.length / samples);\n    const waveform = [];\n\n    for (let i = 0; i < samples; i++) {\n      const start = i * blockSize;\n      const end = start + blockSize;\n      let max = 0;\n      for (let j = start; j < end; j++) {\n        const amplitude = Math.abs(channelData[j]);\n        if (amplitude > max) {\n          max = amplitude;\n        }\n      }\n      waveform.push(max);\n    }\n\n    return waveform;\n  };\n\n  const drawWaveform = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    const width = canvas.width;\n    const height = canvas.height;\n    const barWidth = width / waveformData.length;\n    \n\n    ctx.clearRect(0, 0, width, height);\n\n    waveformData.forEach((value, index) => {\n      const x = index * barWidth;\n      const barHeight = value * height;\n\n      ctx.fillStyle = currentTime / duration > index / waveformData.length ? '#ff5500' : '#999';\n      ctx.fillRect(x, (height - barHeight) / 2, barWidth - 1, barHeight);\n    });\n\n    // segments.forEach((segment) => {\n    //   const startX = (segment.Start / duration) * width;\n    //   const endX = (segment.End / duration) * width;\n    //   ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\"\n    //     ? \"rgba(181, 201, 255, 0.5)\"\n    //     : \"rgba(0, 123, 255, 0.5)\";\n    //   ctx.fillRect(startX, 0, endX - startX, height);\n    // });\n\n    // Добавьте отрисовку ключевых слов\n    keywords.forEach((kw) => {\n      const startX = (kw.keyword.Start / duration) * width;\n      ctx.fillStyle = kw.color;\n      ctx.fillRect(startX, 0, 2, height);\n    });\n    \n  };\n\n  const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    if (!containerRef.current) return;\n    const rect = containerRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const seekTime = (x / rect.width) * duration;\n    onSeek(seekTime);\n  };\n\n  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {\n    const rect = containerRef.current!.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const time = (x / rect.width) * duration;\n\n    const hoveredKw = keywords.find(kw => \n      time >= kw.keyword.Start && time <= kw.keyword.End\n    );\n\n    setHoveredKeyword(hoveredKw || null);\n    setTooltipPosition({ top: e.clientY, left: e.clientX });\n  };\n\n  const handleMouseLeave = () => {\n    setHoveredKeyword(null);\n  };\n\n \n  return (\n    <WaveformContainer \n      ref={containerRef} \n      onClick={handleClick} \n      onMouseMove={handleMouseMove}\n      onMouseLeave={handleMouseLeave}\n    >\n      <WaveformCanvas ref={canvasRef} width={1000} height={200} />\n      <ProgressOverlay progress={(currentTime / duration) * 100} />\n      {hoveredKeyword && (\n        <Tooltip\n          title={`${hoveredKeyword.keyword.Name} (${formatTime(hoveredKeyword.keyword.Start)} - ${formatTime(hoveredKeyword.keyword.End)})`}\n          open={true}\n          style={{\n            position: 'absolute',\n            top: tooltipPosition.top,\n            left: tooltipPosition.left,\n          }}\n        >\n          <div />\n        </Tooltip>\n      )}\n    </WaveformContainer>\n  );\n};\n\nconst formatTime = (time: number) => {\n  const minutes = Math.floor(time / 60);\n  const seconds = Math.floor(time % 60);\n  return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n};\n\n\nexport default AudioWaveform;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,MAAM,EAAEC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAC1D,OAAOC,MAAM,MAAM,mBAAmB;AAEtC,SAASC,OAAO,QAAQ,mBAAmB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE5C,MAAMC,iBAAiB,GAAGJ,MAAM,CAACK,GAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACC,EAAA,GATIF,iBAAiB;AAWvB,MAAMG,cAAc,GAAGP,MAAM,CAACQ,MAAO;AACrC;AACA;AACA;AACA,CAAC;AAACC,GAAA,GAJIF,cAAc;AAMpB,MAAMG,eAAe,GAAGV,MAAM,CAACK,GAA0B;AACzD;AACA;AACA;AACA;AACA,WAAWM,KAAK,IAAIA,KAAK,CAACC,QAAS;AACnC;AACA;AACA,CAAC;AAACC,GAAA,GARIH,eAAe;AAqBrB,MAAMI,aAA2C,GAAGA,CAAC;EACnDC,QAAQ;EACRC,WAAW;EACXC,QAAQ;EACRC,SAAS;EACTC,MAAM;EACNC,WAAW;EACXC,QAAQ;EACRC;AACF,CAAC,KAAK;EAAAC,EAAA;EACJ,MAAMC,SAAS,GAAG3B,MAAM,CAAoB,IAAI,CAAC;EACjD,MAAM4B,YAAY,GAAG5B,MAAM,CAAiB,IAAI,CAAC;EACjD,MAAM,CAAC6B,YAAY,EAAEC,eAAe,CAAC,GAAG5B,QAAQ,CAAW,EAAE,CAAC;EAC9D,MAAM,CAAC6B,cAAc,EAAEC,iBAAiB,CAAC,GAAG9B,QAAQ,CAAsB,IAAI,CAAC;EAC/E,MAAM,CAAC+B,eAAe,EAAEC,kBAAkB,CAAC,GAAGhC,QAAQ,CAAC;IAAEiC,GAAG,EAAE,CAAC;IAAEC,IAAI,EAAE;EAAE,CAAC,CAAC;EAE3EnC,SAAS,CAAC,MAAM;IACd,IAAIiB,QAAQ,EAAE;MACZmB,4BAA4B,CAACnB,QAAQ,CAAC;IACxC;EACF,CAAC,EAAE,CAACA,QAAQ,CAAC,CAAC;EAEdjB,SAAS,CAAC,MAAM;IACdqC,YAAY,CAAC,CAAC;EAChB,CAAC,EAAE,CAACT,YAAY,EAAEV,WAAW,CAAC,CAAC;EAE/B,MAAMkB,4BAA4B,GAAG,MAAOE,GAAW,IAAK;IAC1D,IAAI;MACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAACF,GAAG,CAAC;MACjC,MAAMG,WAAW,GAAG,MAAMF,QAAQ,CAACE,WAAW,CAAC,CAAC;MAChD,MAAMC,YAAY,GAAG,KAAKC,MAAM,CAACC,YAAY,IAAKD,MAAM,CAASE,kBAAkB,EAAE,CAAC;MACtF,MAAMC,WAAW,GAAG,MAAMJ,YAAY,CAACK,eAAe,CAACN,WAAW,CAAC;MACnE,MAAMO,QAAQ,GAAGC,eAAe,CAACH,WAAW,CAAC;MAC7CjB,eAAe,CAACmB,QAAQ,CAAC;IAC3B,CAAC,CAAC,OAAOE,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;IAC/C;EACF,CAAC;EAED,MAAMD,eAAe,GAAIH,WAAwB,IAAK;IACpD,MAAMM,WAAW,GAAGN,WAAW,CAACO,cAAc,CAAC,CAAC,CAAC;IACjD,MAAMC,OAAO,GAAG,GAAG;IACnB,MAAMC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACL,WAAW,CAACM,MAAM,GAAGJ,OAAO,CAAC;IAC1D,MAAMN,QAAQ,GAAG,EAAE;IAEnB,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,OAAO,EAAEK,CAAC,EAAE,EAAE;MAChC,MAAMC,KAAK,GAAGD,CAAC,GAAGJ,SAAS;MAC3B,MAAMM,GAAG,GAAGD,KAAK,GAAGL,SAAS;MAC7B,IAAIO,GAAG,GAAG,CAAC;MACX,KAAK,IAAIC,CAAC,GAAGH,KAAK,EAAEG,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;QAChC,MAAMC,SAAS,GAAGR,IAAI,CAACS,GAAG,CAACb,WAAW,CAACW,CAAC,CAAC,CAAC;QAC1C,IAAIC,SAAS,GAAGF,GAAG,EAAE;UACnBA,GAAG,GAAGE,SAAS;QACjB;MACF;MACAhB,QAAQ,CAACkB,IAAI,CAACJ,GAAG,CAAC;IACpB;IAEA,OAAOd,QAAQ;EACjB,CAAC;EAED,MAAMX,YAAY,GAAGA,CAAA,KAAM;IACzB,MAAM3B,MAAM,GAAGgB,SAAS,CAACyC,OAAO;IAChC,IAAI,CAACzD,MAAM,EAAE;IAEb,MAAM0D,GAAG,GAAG1D,MAAM,CAAC2D,UAAU,CAAC,IAAI,CAAC;IACnC,IAAI,CAACD,GAAG,EAAE;IAEV,MAAME,KAAK,GAAG5D,MAAM,CAAC4D,KAAK;IAC1B,MAAMC,MAAM,GAAG7D,MAAM,CAAC6D,MAAM;IAC5B,MAAMC,QAAQ,GAAGF,KAAK,GAAG1C,YAAY,CAAC8B,MAAM;IAG5CU,GAAG,CAACK,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEH,KAAK,EAAEC,MAAM,CAAC;IAElC3C,YAAY,CAAC8C,OAAO,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAK;MACrC,MAAMC,CAAC,GAAGD,KAAK,GAAGJ,QAAQ;MAC1B,MAAMM,SAAS,GAAGH,KAAK,GAAGJ,MAAM;MAEhCH,GAAG,CAACW,SAAS,GAAG7D,WAAW,GAAGC,QAAQ,GAAGyD,KAAK,GAAGhD,YAAY,CAAC8B,MAAM,GAAG,SAAS,GAAG,MAAM;MACzFU,GAAG,CAACY,QAAQ,CAACH,CAAC,EAAE,CAACN,MAAM,GAAGO,SAAS,IAAI,CAAC,EAAEN,QAAQ,GAAG,CAAC,EAAEM,SAAS,CAAC;IACpE,CAAC,CAAC;;IAEF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACAtD,QAAQ,CAACkD,OAAO,CAAEO,EAAE,IAAK;MACvB,MAAMC,MAAM,GAAID,EAAE,CAACE,OAAO,CAACC,KAAK,GAAGjE,QAAQ,GAAImD,KAAK;MACpDF,GAAG,CAACW,SAAS,GAAGE,EAAE,CAACI,KAAK;MACxBjB,GAAG,CAACY,QAAQ,CAACE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAEX,MAAM,CAAC;IACpC,CAAC,CAAC;EAEJ,CAAC;EAED,MAAMe,WAAW,GAAIC,CAAmC,IAAK;IAC3D,IAAI,CAAC5D,YAAY,CAACwC,OAAO,EAAE;IAC3B,MAAMqB,IAAI,GAAG7D,YAAY,CAACwC,OAAO,CAACsB,qBAAqB,CAAC,CAAC;IACzD,MAAMZ,CAAC,GAAGU,CAAC,CAACG,OAAO,GAAGF,IAAI,CAACrD,IAAI;IAC/B,MAAMwD,QAAQ,GAAId,CAAC,GAAGW,IAAI,CAAClB,KAAK,GAAInD,QAAQ;IAC5CE,MAAM,CAACsE,QAAQ,CAAC;EAClB,CAAC;EAED,MAAMC,eAAe,GAAIL,CAAmC,IAAK;IAC/D,MAAMC,IAAI,GAAG7D,YAAY,CAACwC,OAAO,CAAEsB,qBAAqB,CAAC,CAAC;IAC1D,MAAMZ,CAAC,GAAGU,CAAC,CAACG,OAAO,GAAGF,IAAI,CAACrD,IAAI;IAC/B,MAAM0D,IAAI,GAAIhB,CAAC,GAAGW,IAAI,CAAClB,KAAK,GAAInD,QAAQ;IAExC,MAAM2E,SAAS,GAAGtE,QAAQ,CAACuE,IAAI,CAACd,EAAE,IAChCY,IAAI,IAAIZ,EAAE,CAACE,OAAO,CAACC,KAAK,IAAIS,IAAI,IAAIZ,EAAE,CAACE,OAAO,CAACa,GACjD,CAAC;IAEDjE,iBAAiB,CAAC+D,SAAS,IAAI,IAAI,CAAC;IACpC7D,kBAAkB,CAAC;MAAEC,GAAG,EAAEqD,CAAC,CAACU,OAAO;MAAE9D,IAAI,EAAEoD,CAAC,CAACG;IAAQ,CAAC,CAAC;EACzD,CAAC;EAED,MAAMQ,gBAAgB,GAAGA,CAAA,KAAM;IAC7BnE,iBAAiB,CAAC,IAAI,CAAC;EACzB,CAAC;EAGD,oBACE1B,OAAA,CAACC,iBAAiB;IAChB6F,GAAG,EAAExE,YAAa;IAClByE,OAAO,EAAEd,WAAY;IACrBe,WAAW,EAAET,eAAgB;IAC7BU,YAAY,EAAEJ,gBAAiB;IAAAK,QAAA,gBAE/BlG,OAAA,CAACI,cAAc;MAAC0F,GAAG,EAAEzE,SAAU;MAAC4C,KAAK,EAAE,IAAK;MAACC,MAAM,EAAE;IAAI;MAAAiC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC,eAC5DtG,OAAA,CAACO,eAAe;MAACE,QAAQ,EAAGI,WAAW,GAAGC,QAAQ,GAAI;IAAI;MAAAqF,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC,EAC5D7E,cAAc,iBACbzB,OAAA,CAACF,OAAO;MACNyG,KAAK,EAAG,GAAE9E,cAAc,CAACqD,OAAO,CAAC0B,IAAK,KAAIC,UAAU,CAAChF,cAAc,CAACqD,OAAO,CAACC,KAAK,CAAE,MAAK0B,UAAU,CAAChF,cAAc,CAACqD,OAAO,CAACa,GAAG,CAAE,GAAG;MAClIe,IAAI,EAAE,IAAK;MACXC,KAAK,EAAE;QACLC,QAAQ,EAAE,UAAU;QACpB/E,GAAG,EAAEF,eAAe,CAACE,GAAG;QACxBC,IAAI,EAAEH,eAAe,CAACG;MACxB,CAAE;MAAAoE,QAAA,eAEFlG,OAAA;QAAAmG,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAM;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACA,CACV;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACgB,CAAC;AAExB,CAAC;AAAClF,EAAA,CAvJIT,aAA2C;AAAAkG,GAAA,GAA3ClG,aAA2C;AAyJjD,MAAM8F,UAAU,GAAIjB,IAAY,IAAK;EACnC,MAAMsB,OAAO,GAAG3D,IAAI,CAACC,KAAK,CAACoC,IAAI,GAAG,EAAE,CAAC;EACrC,MAAMuB,OAAO,GAAG5D,IAAI,CAACC,KAAK,CAACoC,IAAI,GAAG,EAAE,CAAC;EACrC,OAAQ,GAAEsB,OAAQ,IAAGC,OAAO,GAAG,EAAE,GAAG,GAAG,GAAG,EAAG,GAAEA,OAAQ,EAAC;AAC1D,CAAC;AAGD,eAAepG,aAAa;AAAC,IAAAR,EAAA,EAAAG,GAAA,EAAAI,GAAA,EAAAmG,GAAA;AAAAG,YAAA,CAAA7G,EAAA;AAAA6G,YAAA,CAAA1G,GAAA;AAAA0G,YAAA,CAAAtG,GAAA;AAAAsG,YAAA,CAAAH,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}