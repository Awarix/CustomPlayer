{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport React, { Children, useMemo } from \"react\";\nimport WaveForm from \"../components/WaveForm\";\nimport WaveSurferContext from \"../contexts/WaveSurferContext\";\nimport getWaveFormOptionsFromProps from \"../utils/getWaveFormOptionsFromProps\";\nimport useWavesurfer from \"../hooks/useWavesurfer\";\n// TODO: research on ref usage\nconst WaveSurfer = _a => {\n  var {\n      children,\n      plugins = [],\n      onMount\n    } = _a,\n    props = __rest(_a, [\"children\", \"plugins\", \"onMount\"]);\n  // Search for WaveForm component props\n  // it's making new logic compatible with old one\n  const UNSTABLE_waveFormProps = useMemo(() => {\n    let waveformProps = {};\n    Children.forEach(children, element => {\n      if (typeof element !== \"object\" || element === null || [\"string\", \"number\"].includes(typeof element)) {\n        return;\n      }\n      // if child does not have either props, or type,\n      // then return\n      if (!(\"props\" in element || \"type\" in element)) return;\n      const props = element.props;\n      const elType = element.type;\n      if (elType === WaveForm) {\n        const {\n            id\n          } = props,\n          rest = __rest(props, [\"id\"]);\n        waveformProps = getWaveFormOptionsFromProps(rest);\n        waveformProps = Object.assign(Object.assign({}, waveformProps), {\n          container: \"#\" + id\n        });\n      }\n    });\n    return waveformProps;\n  }, [children]);\n  const wavesurfer = useWavesurfer(Object.assign(Object.assign({\n    plugins,\n    // TODO: remove in future\n    onMount\n  }, props), UNSTABLE_waveFormProps));\n  return React.createElement(WaveSurferContext.Provider, {\n    value: wavesurfer\n  }, children);\n};\nWaveSurfer.defaultProps = {\n  children: null,\n  plugins: []\n};\nexport default WaveSurfer;","map":{"version":3,"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","React","Children","useMemo","WaveForm","WaveSurferContext","getWaveFormOptionsFromProps","useWavesurfer","WaveSurfer","_a","children","plugins","onMount","props","UNSTABLE_waveFormProps","waveformProps","forEach","element","includes","elType","type","id","rest","assign","container","wavesurfer","createElement","Provider","value","defaultProps"],"sources":["/home/gleb/my_app_test/node_modules/wavesurfer-react/dist/containers/WaveSurfer.js"],"sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport React, { Children, useMemo } from \"react\";\nimport WaveForm from \"../components/WaveForm\";\nimport WaveSurferContext from \"../contexts/WaveSurferContext\";\nimport getWaveFormOptionsFromProps from \"../utils/getWaveFormOptionsFromProps\";\nimport useWavesurfer from \"../hooks/useWavesurfer\";\n// TODO: research on ref usage\nconst WaveSurfer = (_a) => {\n    var { children, plugins = [], onMount } = _a, props = __rest(_a, [\"children\", \"plugins\", \"onMount\"]);\n    // Search for WaveForm component props\n    // it's making new logic compatible with old one\n    const UNSTABLE_waveFormProps = useMemo(() => {\n        let waveformProps = {};\n        Children.forEach(children, (element) => {\n            if (typeof element !== \"object\" || element === null || [\"string\", \"number\"].includes(typeof element)) {\n                return;\n            }\n            // if child does not have either props, or type,\n            // then return\n            if (!(\"props\" in element || \"type\" in element))\n                return;\n            const props = element.props;\n            const elType = element.type;\n            if (elType === WaveForm) {\n                const { id } = props, rest = __rest(props, [\"id\"]);\n                waveformProps = getWaveFormOptionsFromProps(rest);\n                waveformProps = Object.assign(Object.assign({}, waveformProps), { container: \"#\" + id });\n            }\n        });\n        return waveformProps;\n    }, [children]);\n    const wavesurfer = useWavesurfer(Object.assign(Object.assign({ plugins,\n        // TODO: remove in future\n        onMount }, props), UNSTABLE_waveFormProps));\n    return (React.createElement(WaveSurferContext.Provider, { value: wavesurfer }, children));\n};\nWaveSurfer.defaultProps = {\n    children: null,\n    plugins: [],\n};\nexport default WaveSurfer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}