{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useEffect, useRef } from \"react\";\nimport useWavesurferContext from \"../hooks/useWavesurferContext\";\n// TODO: remove boilerplate in useEffects section, try to update useRegionEvent to support\n//  all kinds of event handling within WaveSurfer ecosystem\nexport default function Marker(_a) {\n  var {\n      onClick,\n      onDrop,\n      onDrag\n    } = _a,\n    data = __rest(_a, [\"onClick\", \"onDrop\", \"onDrag\"]);\n  const ws = useWavesurferContext();\n  // TODO: make some kind of useGetLatestWs...\n  const ws$ = useRef(ws);\n  useEffect(() => {\n    ws$.current = ws;\n  }, [ws]);\n  // This is the only legal/official way to identify marker\n  // inside wavesurfer markers list and\n  // to tie it with Marker component\n  const isRendered = useRef(false);\n  const markerEl = useRef(null);\n  useEffect(() => {\n    if (!ws) return;\n    if (!onClick) return;\n    function handler(marker, event) {\n      if (!markerEl.current) return;\n      if (marker.el !== markerEl.current.el) return;\n      onClick === null || onClick === void 0 ? void 0 : onClick(marker, event);\n    }\n    ws.on(\"marker-click\", handler);\n    return () => {\n      ws.un(\"marker-click\", handler);\n    };\n  }, [ws, onClick]);\n  useEffect(() => {\n    if (!ws) return;\n    if (!onDrag) return;\n    function handler(marker, event) {\n      if (!markerEl.current) return;\n      if (marker.el !== markerEl.current.el) return;\n      onDrag === null || onDrag === void 0 ? void 0 : onDrag(marker, event);\n    }\n    ws.on(\"marker-drag\", handler);\n    return () => {\n      ws.un(\"marker-drag\", handler);\n    };\n  }, [ws, onDrag]);\n  useEffect(() => {\n    if (!ws) return;\n    if (!onDrop) return;\n    function handler(marker, event) {\n      if (!markerEl.current) return;\n      if (marker.el !== markerEl.current.el) return;\n      onDrop === null || onDrop === void 0 ? void 0 : onDrop(marker, event);\n    }\n    ws.on(\"marker-drop\", handler);\n    return () => {\n      ws.un(\"marker-drop\", handler);\n    };\n  }, [ws, onDrop]);\n  useEffect(() => {\n    if (!ws) return;\n    // THERE CAN BE ONLY ONE\n    // ...\n    // ...\n    // ...\n    // marker creation for each Marker component.\n    // If there is a better way, PRs welcome!\n    if (isRendered.current) return;\n    isRendered.current = true;\n    // create marker: marker becomes visible at the same time\n    markerEl.current = ws.addMarker(data);\n  }, [ws]);\n  useEffect(() => {\n    var _a;\n    if (!ws || !markerEl.current || !isRendered.current) return;\n    // Проверяем что изменения реально имели место быть,\n    // но снаружи, а не внутри\n    // На данный момент, меняется только позиция\n    if (data.time === ((_a = markerEl.current) === null || _a === void 0 ? void 0 : _a.time)) return;\n    // When wavesurfer will officially make markers fully updatable,\n    // then it will be done in other way, for now it's enough.\n    //\n    // For enthusiasts, it is possible to deep dive into the process of marker creation and make a PR,\n    // that will add full marker update support.\n    // https://wavesurfer-js.org/api/file/src/plugin/markers/index.js.html\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const marker = ws.markers.markers.find(mark => {\n      var _a;\n      return mark.el === ((_a = markerEl.current) === null || _a === void 0 ? void 0 : _a.el);\n    });\n    if (!marker) return;\n    marker.time = data.time;\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    ws.markers._updateMarkerPosition(Object.assign(Object.assign({}, markerEl.current), {\n      time: data.time\n    }));\n  }, [data === null || data === void 0 ? void 0 : data.time]);\n  // Maybe it will require to create some single source of truth for Markers,\n  // as far as they are working via wavesurfer instance. That's making'em\n  // different from Regions in the way of working.\n  useEffect(() => () => {\n    if (!ws$.current || !markerEl.current) return;\n    const index = ws$.current.markers.markers.findIndex(marker => {\n      var _a;\n      return marker.el === ((_a = markerEl.current) === null || _a === void 0 ? void 0 : _a.el);\n    });\n    ws$.current.markers.remove(index);\n  }, []);\n  return null;\n}","map":{"version":3,"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","useEffect","useRef","useWavesurferContext","Marker","_a","onClick","onDrop","onDrag","data","ws","ws$","current","isRendered","markerEl","handler","marker","event","el","on","un","addMarker","time","markers","find","mark","_updateMarkerPosition","assign","index","findIndex","remove"],"sources":["/home/gleb/my_app_test/node_modules/wavesurfer-react/dist/components/Marker.js"],"sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { useEffect, useRef } from \"react\";\nimport useWavesurferContext from \"../hooks/useWavesurferContext\";\n// TODO: remove boilerplate in useEffects section, try to update useRegionEvent to support\n//  all kinds of event handling within WaveSurfer ecosystem\nexport default function Marker(_a) {\n    var { onClick, onDrop, onDrag } = _a, data = __rest(_a, [\"onClick\", \"onDrop\", \"onDrag\"]);\n    const ws = useWavesurferContext();\n    // TODO: make some kind of useGetLatestWs...\n    const ws$ = useRef(ws);\n    useEffect(() => {\n        ws$.current = ws;\n    }, [ws]);\n    // This is the only legal/official way to identify marker\n    // inside wavesurfer markers list and\n    // to tie it with Marker component\n    const isRendered = useRef(false);\n    const markerEl = useRef(null);\n    useEffect(() => {\n        if (!ws)\n            return;\n        if (!onClick)\n            return;\n        function handler(marker, event) {\n            if (!markerEl.current)\n                return;\n            if (marker.el !== markerEl.current.el)\n                return;\n            onClick === null || onClick === void 0 ? void 0 : onClick(marker, event);\n        }\n        ws.on(\"marker-click\", handler);\n        return () => {\n            ws.un(\"marker-click\", handler);\n        };\n    }, [ws, onClick]);\n    useEffect(() => {\n        if (!ws)\n            return;\n        if (!onDrag)\n            return;\n        function handler(marker, event) {\n            if (!markerEl.current)\n                return;\n            if (marker.el !== markerEl.current.el)\n                return;\n            onDrag === null || onDrag === void 0 ? void 0 : onDrag(marker, event);\n        }\n        ws.on(\"marker-drag\", handler);\n        return () => {\n            ws.un(\"marker-drag\", handler);\n        };\n    }, [ws, onDrag]);\n    useEffect(() => {\n        if (!ws)\n            return;\n        if (!onDrop)\n            return;\n        function handler(marker, event) {\n            if (!markerEl.current)\n                return;\n            if (marker.el !== markerEl.current.el)\n                return;\n            onDrop === null || onDrop === void 0 ? void 0 : onDrop(marker, event);\n        }\n        ws.on(\"marker-drop\", handler);\n        return () => {\n            ws.un(\"marker-drop\", handler);\n        };\n    }, [ws, onDrop]);\n    useEffect(() => {\n        if (!ws)\n            return;\n        // THERE CAN BE ONLY ONE\n        // ...\n        // ...\n        // ...\n        // marker creation for each Marker component.\n        // If there is a better way, PRs welcome!\n        if (isRendered.current)\n            return;\n        isRendered.current = true;\n        // create marker: marker becomes visible at the same time\n        markerEl.current = ws.addMarker(data);\n    }, [ws]);\n    useEffect(() => {\n        var _a;\n        if (!ws || !markerEl.current || !isRendered.current)\n            return;\n        // Проверяем что изменения реально имели место быть,\n        // но снаружи, а не внутри\n        // На данный момент, меняется только позиция\n        if (data.time === ((_a = markerEl.current) === null || _a === void 0 ? void 0 : _a.time))\n            return;\n        // When wavesurfer will officially make markers fully updatable,\n        // then it will be done in other way, for now it's enough.\n        //\n        // For enthusiasts, it is possible to deep dive into the process of marker creation and make a PR,\n        // that will add full marker update support.\n        // https://wavesurfer-js.org/api/file/src/plugin/markers/index.js.html\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        const marker = ws.markers.markers.find(mark => { var _a; return mark.el === ((_a = markerEl.current) === null || _a === void 0 ? void 0 : _a.el); });\n        if (!marker)\n            return;\n        marker.time = data.time;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        ws.markers._updateMarkerPosition(Object.assign(Object.assign({}, markerEl.current), { time: data.time }));\n    }, [data === null || data === void 0 ? void 0 : data.time]);\n    // Maybe it will require to create some single source of truth for Markers,\n    // as far as they are working via wavesurfer instance. That's making'em\n    // different from Regions in the way of working.\n    useEffect(() => () => {\n        if (!ws$.current || !markerEl.current)\n            return;\n        const index = ws$.current.markers.markers.findIndex((marker) => {\n            var _a;\n            return marker.el === ((_a = markerEl.current) === null || _a === void 0 ? void 0 : _a.el);\n        });\n        ws$.current.markers.remove(index);\n    }, []);\n    return null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}