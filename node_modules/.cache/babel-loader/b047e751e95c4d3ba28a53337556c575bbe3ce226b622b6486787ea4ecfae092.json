{"ast":null,"code":"var _jsxFileName = \"/home/gleb/my_app_test/src/audio/AudioPlayer.tsx\",\n  _s = $RefreshSig$();\n// AudioPlayer.tsx\nimport React, { useRef, useEffect, useState } from 'react';\nimport { useAudio } from './AudioContext';\nimport styled from 'styled-components';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst PlayerContainer = styled.div`\n  background-color: #2c3e50;\n  padding: 20px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n`;\n_c = PlayerContainer;\nconst PlayButton = styled.button`\n  background-color: #3498db;\n  color: white;\n  border: none;\n  padding: 10px 20px;\n  font-size: 16px;\n  border-radius: 4px;\n  cursor: pointer;\n  transition: background-color 0.3s;\n\n  &:hover {\n    background-color: #2980b9;\n  }\n\n  &:focus {\n    outline: none;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.5);\n  }\n`;\n_c2 = PlayButton;\nconst Canvas = styled.canvas`\n  margin-top: 20px;\n  background-color: #34495e;\n  border-radius: 4px;\n`;\n_c3 = Canvas;\nconst AudioPlayer = () => {\n  _s();\n  const {\n    currentAudioUrl\n  } = useAudio();\n  const audioContextRef = useRef(null);\n  const sourceNodeRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  useEffect(() => {\n    audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();\n    return () => {\n      var _audioContextRef$curr;\n      (_audioContextRef$curr = audioContextRef.current) === null || _audioContextRef$curr === void 0 ? void 0 : _audioContextRef$curr.close();\n    };\n  }, []);\n  const playAudio = async () => {\n    const currentAudioUrl = 'http://webaudioapi.com/samples/audio-tag/chrono.mp3';\n    if (!audioContextRef.current || !currentAudioUrl) {\n      console.log('AudioContext or currentAudioUrl is not available');\n      return;\n    }\n    if (sourceNodeRef.current) {\n      sourceNodeRef.current.stop();\n    }\n    try {\n      console.log('Fetching audio from:', currentAudioUrl);\n      const response = await fetch(currentAudioUrl);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      console.log('Audio fetched, decoding...');\n      const arrayBuffer = await response.arrayBuffer();\n      const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);\n      console.log('Audio decoded, creating source...');\n      sourceNodeRef.current = audioContextRef.current.createBufferSource();\n      sourceNodeRef.current.buffer = audioBuffer;\n      sourceNodeRef.current.connect(audioContextRef.current.destination);\n      const analyser = audioContextRef.current.createAnalyser();\n      sourceNodeRef.current.connect(analyser);\n      console.log('Starting playback...');\n      sourceNodeRef.current.start();\n      setIsPlaying(true);\n      drawOscilloscope(analyser);\n    } catch (error) {\n      console.error('Error loading or playing audio:', error);\n      setIsPlaying(false);\n    }\n  };\n  const drawOscilloscope = analyser => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const canvasCtx = canvas.getContext('2d');\n    if (!canvasCtx) return;\n    const draw = () => {\n      const WIDTH = canvas.width;\n      const HEIGHT = canvas.height;\n      analyser.fftSize = 2048;\n      const bufferLength = analyser.fftSize;\n      const dataArray = new Uint8Array(bufferLength);\n      canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);\n      const drawVisual = requestAnimationFrame(draw);\n      analyser.getByteTimeDomainData(dataArray);\n      canvasCtx.lineWidth = 2;\n      canvasCtx.strokeStyle = 'rgb(0, 255, 0)';\n      canvasCtx.beginPath();\n      const sliceWidth = WIDTH * 1.0 / bufferLength;\n      let x = 0;\n      for (let i = 0; i < bufferLength; i++) {\n        const v = dataArray[i] / 128.0;\n        const y = v * HEIGHT / 2;\n        if (i === 0) {\n          canvasCtx.moveTo(x, y);\n        } else {\n          canvasCtx.lineTo(x, y);\n        }\n        x += sliceWidth;\n      }\n      canvasCtx.lineTo(canvas.width, canvas.height / 2);\n      canvasCtx.stroke();\n    };\n    draw();\n  };\n  const stopAudio = () => {\n    if (sourceNodeRef.current) {\n      sourceNodeRef.current.stop();\n      setIsPlaying(false);\n    }\n  };\n\n  // Добавим отображение текущего аудиофайла\n  const AudioInfo = styled.div`\n    color: white;\n    margin-bottom: 10px;\n    font-size: 14px;\n    `;\n  return /*#__PURE__*/_jsxDEV(PlayerContainer, {\n    children: [/*#__PURE__*/_jsxDEV(AudioInfo, {\n      children: currentAudioUrl ? `Now playing: ${currentAudioUrl.split('/').pop()}` : 'No audio selected'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 163,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(PlayButton, {\n      onClick: isPlaying ? stopAudio : playAudio,\n      children: isPlaying ? 'Stop' : 'Play'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 166,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(Canvas, {\n      ref: canvasRef,\n      width: \"800\",\n      height: \"200\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 169,\n      columnNumber: 5\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 162,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioPlayer, \"/4x+V1z9fk+5YuXzBy3A8VFFycQ=\", false, function () {\n  return [useAudio];\n});\n_c4 = AudioPlayer;\nexport default AudioPlayer;\nvar _c, _c2, _c3, _c4;\n$RefreshReg$(_c, \"PlayerContainer\");\n$RefreshReg$(_c2, \"PlayButton\");\n$RefreshReg$(_c3, \"Canvas\");\n$RefreshReg$(_c4, \"AudioPlayer\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useAudio","styled","jsxDEV","_jsxDEV","PlayerContainer","div","_c","PlayButton","button","_c2","Canvas","canvas","_c3","AudioPlayer","_s","currentAudioUrl","audioContextRef","sourceNodeRef","canvasRef","isPlaying","setIsPlaying","current","window","AudioContext","webkitAudioContext","_audioContextRef$curr","close","playAudio","console","log","stop","response","fetch","ok","Error","status","arrayBuffer","audioBuffer","decodeAudioData","createBufferSource","buffer","connect","destination","analyser","createAnalyser","start","drawOscilloscope","error","canvasCtx","getContext","draw","WIDTH","width","HEIGHT","height","fftSize","bufferLength","dataArray","Uint8Array","clearRect","drawVisual","requestAnimationFrame","getByteTimeDomainData","lineWidth","strokeStyle","beginPath","sliceWidth","x","i","v","y","moveTo","lineTo","stroke","stopAudio","AudioInfo","children","split","pop","fileName","_jsxFileName","lineNumber","columnNumber","onClick","ref","_c4","$RefreshReg$"],"sources":["/home/gleb/my_app_test/src/audio/AudioPlayer.tsx"],"sourcesContent":["// AudioPlayer.tsx\nimport React, { useRef, useEffect, useState } from 'react';\nimport { useAudio } from './AudioContext';\nimport styled from 'styled-components';\n\nconst PlayerContainer = styled.div`\n  background-color: #2c3e50;\n  padding: 20px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n`;\n\nconst PlayButton = styled.button`\n  background-color: #3498db;\n  color: white;\n  border: none;\n  padding: 10px 20px;\n  font-size: 16px;\n  border-radius: 4px;\n  cursor: pointer;\n  transition: background-color 0.3s;\n\n  &:hover {\n    background-color: #2980b9;\n  }\n\n  &:focus {\n    outline: none;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.5);\n  }\n`;\n\nconst Canvas = styled.canvas`\n  margin-top: 20px;\n  background-color: #34495e;\n  border-radius: 4px;\n`;\n\n\nconst AudioPlayer: React.FC = () => {\n  const { currentAudioUrl } = useAudio();\n  const audioContextRef = useRef<AudioContext | null>(null);\n  const sourceNodeRef = useRef<AudioBufferSourceNode | null>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n\n  useEffect(() => {\n    audioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)();\n    return () => {\n      audioContextRef.current?.close();\n    };\n  }, []);\n\n  const playAudio = async () => {\n    const currentAudioUrl = 'http://webaudioapi.com/samples/audio-tag/chrono.mp3'\n    if (!audioContextRef.current || !currentAudioUrl) {\n      console.log('AudioContext or currentAudioUrl is not available');\n      return;\n    }\n  \n    if (sourceNodeRef.current) {\n      sourceNodeRef.current.stop();\n    }\n  \n    try {\n      console.log('Fetching audio from:', currentAudioUrl);\n      const response = await fetch(currentAudioUrl);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      console.log('Audio fetched, decoding...');\n      const arrayBuffer = await response.arrayBuffer();\n      const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);\n  \n      console.log('Audio decoded, creating source...');\n      sourceNodeRef.current = audioContextRef.current.createBufferSource();\n      sourceNodeRef.current.buffer = audioBuffer;\n      sourceNodeRef.current.connect(audioContextRef.current.destination);\n  \n      const analyser = audioContextRef.current.createAnalyser();\n      sourceNodeRef.current.connect(analyser);\n  \n      console.log('Starting playback...');\n      sourceNodeRef.current.start();\n      setIsPlaying(true);\n  \n      drawOscilloscope(analyser);\n    } catch (error) {\n      console.error('Error loading or playing audio:', error);\n      setIsPlaying(false);\n    }\n  };\n    \n\n  const drawOscilloscope = (analyser: AnalyserNode) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const canvasCtx = canvas.getContext('2d');\n    if (!canvasCtx) return;\n\n    const draw = () => {\n      const WIDTH = canvas.width;\n      const HEIGHT = canvas.height;\n\n      analyser.fftSize = 2048;\n      const bufferLength = analyser.fftSize;\n      const dataArray = new Uint8Array(bufferLength);\n\n      canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);\n\n      const drawVisual = requestAnimationFrame(draw);\n\n      analyser.getByteTimeDomainData(dataArray);\n\n      canvasCtx.lineWidth = 2;\n\n      canvasCtx.strokeStyle = 'rgb(0, 255, 0)';\n      canvasCtx.beginPath();\n\n      const sliceWidth = WIDTH * 1.0 / bufferLength;\n      let x = 0;\n\n      for (let i = 0; i < bufferLength; i++) {\n        const v = dataArray[i] / 128.0;\n        const y = v * HEIGHT / 2;\n\n        if (i === 0) {\n          canvasCtx.moveTo(x, y);\n        } else {\n          canvasCtx.lineTo(x, y);\n        }\n\n        x += sliceWidth;\n      }\n\n      canvasCtx.lineTo(canvas.width, canvas.height / 2);\n      canvasCtx.stroke();\n    };\n\n    draw();\n  };\n\n  const stopAudio = () => {\n    if (sourceNodeRef.current) {\n      sourceNodeRef.current.stop();\n      setIsPlaying(false);\n    }\n  };\n\n  // Добавим отображение текущего аудиофайла\n    const AudioInfo = styled.div`\n    color: white;\n    margin-bottom: 10px;\n    font-size: 14px;\n    `;\n\n  return (\n    <PlayerContainer>\n    <AudioInfo>\n      {currentAudioUrl ? `Now playing: ${currentAudioUrl.split('/').pop()}` : 'No audio selected'}\n    </AudioInfo>\n    <PlayButton onClick={isPlaying ? stopAudio : playAudio}>\n      {isPlaying ? 'Stop' : 'Play'}\n    </PlayButton>\n    <Canvas ref={canvasRef} width=\"800\" height=\"200\" />\n  </PlayerContainer>\n  );\n};\n\nexport default AudioPlayer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}