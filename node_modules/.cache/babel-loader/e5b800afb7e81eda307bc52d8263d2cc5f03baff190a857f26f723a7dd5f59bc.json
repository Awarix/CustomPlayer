{"ast":null,"code":"var _jsxFileName = \"/home/gleb/my_app_test/src/audio/AudioWaveform.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WaveformContainer = styled.div`\n  width: 100%;\n  height: 100px;\n  position: relative;\n  background-color: #f1f3f4;\n  border-radius: 4px;\n  overflow: hidden;\n  cursor: pointer;\n  padding: 30px 0px;\n`;\n_c = WaveformContainer;\nconst WaveformCanvas = styled.canvas`\n  width: 100%;\n  height: 100%;\n  background-color: #f4h2a1;\n`;\n_c2 = WaveformCanvas;\nconst ProgressOverlay = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: ${props => props.progress}%;\n  background-color: rgba(77, 182, 172, 0.2);\n  pointer-events: none;\n`;\n_c3 = ProgressOverlay;\nconst AudioWaveform = ({\n  audioUrl,\n  currentTime,\n  duration,\n  isPlaying,\n  onSeek,\n  onPlayPause,\n  segments,\n  keywords,\n  zoomLevel\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const containerRef = useRef(null);\n  const [waveformData, setWaveformData] = useState([]);\n  const [hoveredKeyword, setHoveredKeyword] = useState(null);\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [popoverPosition, setPopoverPosition] = useState({\n    top: 0,\n    left: 0\n  });\n  useEffect(() => {\n    if (audioUrl) {\n      fetchAudioAndComputeWaveform(audioUrl);\n    }\n  }, [audioUrl]);\n  useEffect(() => {\n    drawWaveform();\n  }, [waveformData, currentTime, zoomLevel]);\n  const fetchAudioAndComputeWaveform = async url => {\n    try {\n      const response = await fetch(url);\n      const arrayBuffer = await response.arrayBuffer();\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n      const waveform = computeWaveform(audioBuffer);\n      setWaveformData(waveform);\n    } catch (error) {\n      console.error('Error fetching audio:', error);\n    }\n  };\n  const computeWaveform = audioBuffer => {\n    const channelData = audioBuffer.getChannelData(0);\n    const samples = 500 * zoomLevel; // увеличиваем количество выборок в зависимости от уровня зума\n    const blockSize = Math.floor(channelData.length / samples);\n    const waveform = [];\n    for (let i = 0; i < samples; i++) {\n      const start = i * blockSize;\n      const end = start + blockSize;\n      let max = 0;\n      for (let j = start; j < end; j++) {\n        const amplitude = Math.abs(channelData[j]);\n        if (amplitude > max) {\n          max = amplitude;\n        }\n      }\n      waveform.push(max);\n    }\n    return waveform;\n  };\n  const drawWaveform = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    const width = canvas.width;\n    const height = canvas.height;\n    const barWidth = width / waveformData.length;\n    ctx.clearRect(0, 0, width, height);\n    waveformData.forEach((value, index) => {\n      const x = index * barWidth;\n      const barHeight = value * height;\n      ctx.fillStyle = currentTime / duration > index / waveformData.length ? '#357F78' : '#999';\n      ctx.fillRect(x, (height - barHeight) / 2, barWidth - 1, barHeight);\n    });\n    segments.forEach(segment => {\n      const startX = segment.Start / duration * width;\n      const endX = segment.End / duration * width;\n      ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\" ? \"rgba(181, 201, 255, 0.5)\" : \"rgba(0, 123, 255, 0.5)\";\n      ctx.fillRect(startX, 0, endX - startX, height);\n    });\n\n    // Отрисовка ключевых слов\n    keywords.forEach(kw => {\n      const startX = kw.keyword.Start / duration * width;\n      ctx.fillStyle = kw.color;\n      ctx.fillRect(startX, 0.5, 1, height / 2);\n    });\n  };\n  const handleClick = e => {\n    if (!containerRef.current) return;\n    const rect = containerRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const seekTime = x / rect.width * duration;\n    onSeek(seekTime);\n  };\n  const handleMouseMove = e => {\n    const rect = containerRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const time = x / rect.width * duration;\n    const hoveredKw = keywords.find(kw => time >= kw.keyword.Start && time <= kw.keyword.End);\n    if (hoveredKw) {\n      setHoveredKeyword(hoveredKw);\n      setPopoverPosition({\n        top: e.clientY - rect.top,\n        left: x\n      });\n      setAnchorEl(containerRef.current);\n    } else {\n      setHoveredKeyword(null);\n      setAnchorEl(null);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(WaveformContainer, {\n    ref: containerRef,\n    onClick: handleClick,\n    onMouseMove: handleMouseMove,\n    children: [/*#__PURE__*/_jsxDEV(WaveformCanvas, {\n      ref: canvasRef,\n      width: 1000,\n      height: 200\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 183,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(ProgressOverlay, {\n      progress: currentTime / duration * 100\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 184,\n      columnNumber: 7\n    }, this), hoveredKeyword && anchorEl && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'absolute',\n        top: popoverPosition.top + 15,\n        left: popoverPosition.left,\n        transform: 'translateX(-50%)',\n        backgroundColor: 'white',\n        border: '1px solid #ccc',\n        borderRadius: '4px',\n        padding: '8px',\n        boxShadow: '0 2px 10px rgba(0,0,0,0.1)',\n        zIndex: 1000\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          marginBottom: '10px'\n        },\n        children: `${hoveredKeyword.keyword.Name} ( ${(hoveredKeyword.keyword.Confidence * 100).toFixed(0)}% )`\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 200,\n        columnNumber: 5\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [formatTime(hoveredKeyword.keyword.Start), \" - \", formatTime(hoveredKeyword.keyword.End)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 203,\n        columnNumber: 5\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 186,\n      columnNumber: 3\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 178,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioWaveform, \"IkQGjRgfF3mTmQMebSYpAJ3IFQQ=\");\n_c4 = AudioWaveform;\nconst formatTime = time => {\n  const minutes = Math.floor(time / 60);\n  const seconds = Math.floor(time % 60);\n  return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n};\nexport default AudioWaveform;\nvar _c, _c2, _c3, _c4;\n$RefreshReg$(_c, \"WaveformContainer\");\n$RefreshReg$(_c2, \"WaveformCanvas\");\n$RefreshReg$(_c3, \"ProgressOverlay\");\n$RefreshReg$(_c4, \"AudioWaveform\");","map":{"version":3,"names":["React","useRef","useEffect","useState","styled","jsxDEV","_jsxDEV","WaveformContainer","div","_c","WaveformCanvas","canvas","_c2","ProgressOverlay","props","progress","_c3","AudioWaveform","audioUrl","currentTime","duration","isPlaying","onSeek","onPlayPause","segments","keywords","zoomLevel","_s","canvasRef","containerRef","waveformData","setWaveformData","hoveredKeyword","setHoveredKeyword","anchorEl","setAnchorEl","popoverPosition","setPopoverPosition","top","left","fetchAudioAndComputeWaveform","drawWaveform","url","response","fetch","arrayBuffer","audioContext","window","AudioContext","webkitAudioContext","audioBuffer","decodeAudioData","waveform","computeWaveform","error","console","channelData","getChannelData","samples","blockSize","Math","floor","length","i","start","end","max","j","amplitude","abs","push","current","ctx","getContext","width","height","barWidth","clearRect","forEach","value","index","x","barHeight","fillStyle","fillRect","segment","startX","Start","endX","End","Words","NormalForm","kw","keyword","color","handleClick","e","rect","getBoundingClientRect","clientX","seekTime","handleMouseMove","time","hoveredKw","find","clientY","ref","onClick","onMouseMove","children","fileName","_jsxFileName","lineNumber","columnNumber","style","position","transform","backgroundColor","border","borderRadius","padding","boxShadow","zIndex","marginBottom","Name","Confidence","toFixed","formatTime","_c4","minutes","seconds","$RefreshReg$"],"sources":["/home/gleb/my_app_test/src/audio/AudioWaveform.tsx"],"sourcesContent":["import React, { useRef, useEffect, useState, MouseEvent } from 'react';\nimport styled from 'styled-components';\nimport { KeywordColor, SegmentModel } from './AudioContext';\n\nconst WaveformContainer = styled.div`\n  width: 100%;\n  height: 100px;\n  position: relative;\n  background-color: #f1f3f4;\n  border-radius: 4px;\n  overflow: hidden;\n  cursor: pointer;\n  padding: 30px 0px;\n`;\n\nconst WaveformCanvas = styled.canvas`\n  width: 100%;\n  height: 100%;\n  background-color: #f4h2a1;\n`;\n\nconst ProgressOverlay = styled.div<{ progress: number }>`\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: ${props => props.progress}%;\n  background-color: rgba(77, 182, 172, 0.2);\n  pointer-events: none;\n`;\n\ninterface AudioWaveformProps {\n  audioUrl: string;\n  currentTime: number;\n  duration: number;\n  isPlaying: boolean;\n  onSeek: (time: number) => void;\n  onPlayPause: () => void;\n  segments: SegmentModel[];\n  keywords: KeywordColor[];\n  zoomLevel: number;\n}\n\nconst AudioWaveform: React.FC<AudioWaveformProps> = ({\n  audioUrl,\n  currentTime,\n  duration,\n  isPlaying,\n  onSeek,\n  onPlayPause,\n  segments,\n  keywords,\n  zoomLevel,\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [waveformData, setWaveformData] = useState<number[]>([]);\n  const [hoveredKeyword, setHoveredKeyword] = useState<KeywordColor | null>(null);\n  const [anchorEl, setAnchorEl] = useState<HTMLElement | null>(null);\n  const [popoverPosition, setPopoverPosition] = useState({ top: 0, left: 0 });\n\n  useEffect(() => {\n    if (audioUrl) {\n      fetchAudioAndComputeWaveform(audioUrl);\n    }\n  }, [audioUrl]);\n\n  useEffect(() => {\n    drawWaveform();\n  }, [waveformData, currentTime, zoomLevel]);\n\n  const fetchAudioAndComputeWaveform = async (url: string) => {\n    try {\n      const response = await fetch(url);\n      const arrayBuffer = await response.arrayBuffer();\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n      const waveform = computeWaveform(audioBuffer);\n      setWaveformData(waveform);\n    } catch (error) {\n      console.error('Error fetching audio:', error);\n    }\n  };\n\n  const computeWaveform = (audioBuffer: AudioBuffer) => {\n    const channelData = audioBuffer.getChannelData(0);\n    const samples = 500 * zoomLevel; // увеличиваем количество выборок в зависимости от уровня зума\n    const blockSize = Math.floor(channelData.length / samples);\n    const waveform = [];\n\n    for (let i = 0; i < samples; i++) {\n      const start = i * blockSize;\n      const end = start + blockSize;\n      let max = 0;\n      for (let j = start; j < end; j++) {\n        const amplitude = Math.abs(channelData[j]);\n        if (amplitude > max) {\n          max = amplitude;\n        }\n      }\n      waveform.push(max);\n    }\n\n    return waveform;\n  };\n\n  const drawWaveform = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    const width = canvas.width;\n    const height = canvas.height;\n    const barWidth = width / waveformData.length;\n    \n\n    ctx.clearRect(0, 0, width, height);\n\n    waveformData.forEach((value, index) => {\n      const x = index * barWidth;\n      const barHeight = value * height;\n\n      ctx.fillStyle = currentTime / duration > index / waveformData.length ? '#357F78' : '#999';\n      ctx.fillRect(x, (height - barHeight) / 2, barWidth - 1, barHeight);\n    });\n\n    segments.forEach((segment) => {\n      const startX = (segment.Start / duration) * width;\n      const endX = (segment.End / duration) * width;\n      ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\"\n        ? \"rgba(181, 201, 255, 0.5)\"\n        : \"rgba(0, 123, 255, 0.5)\";\n      ctx.fillRect(startX, 0, endX - startX, height);\n    });\n\n    // Отрисовка ключевых слов\n    keywords.forEach((kw) => {\n      \n      const startX = (kw.keyword.Start / duration) * width;\n      ctx.fillStyle = kw.color;\n      ctx.fillRect(startX, 0.5, 1, height / 2 );\n    });\n    \n  };\n\n  const handleClick = (e: MouseEvent<HTMLDivElement>) => {\n    if (!containerRef.current) return;\n    const rect = containerRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const seekTime = (x / rect.width) * duration;\n    onSeek(seekTime);\n  };\n\n  const handleMouseMove = (e: MouseEvent<HTMLDivElement>) => {\n    const rect = containerRef.current!.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const time = (x / rect.width) * duration;\n  \n    const hoveredKw = keywords.find(kw => \n      time >= kw.keyword.Start && time <= kw.keyword.End\n    );\n  \n    if (hoveredKw) {\n      setHoveredKeyword(hoveredKw);\n      setPopoverPosition({ top: e.clientY - rect.top, left: x });\n      setAnchorEl(containerRef.current);\n    } else {\n      setHoveredKeyword(null);\n      setAnchorEl(null);\n    }\n  };\n\n\n \n  return (\n    <WaveformContainer \n      ref={containerRef} \n      onClick={handleClick} \n      onMouseMove={handleMouseMove}\n    >\n      <WaveformCanvas ref={canvasRef} width={1000} height={200} />\n      <ProgressOverlay progress={(currentTime / duration) * 100} />\n      {hoveredKeyword && anchorEl && (\n  <div\n    style={{\n      position: 'absolute',\n      top: popoverPosition.top + 15, \n      left: popoverPosition.left,\n      transform: 'translateX(-50%)', \n      backgroundColor: 'white',\n      border: '1px solid #ccc',\n      borderRadius: '4px',\n      padding: '8px',\n      boxShadow: '0 2px 10px rgba(0,0,0,0.1)',\n      zIndex: 1000,\n    }}\n  >\n    <div style={{ marginBottom: '10px' }}>\n      {`${hoveredKeyword.keyword.Name} ( ${(hoveredKeyword.keyword.Confidence * 100).toFixed(0)}% )`}\n    </div>\n    <div>\n      {formatTime(hoveredKeyword.keyword.Start)} - {formatTime(hoveredKeyword.keyword.End)}\n    </div>\n  </div>\n)}\n    </WaveformContainer>\n  );\n};\n\nconst formatTime = (time: number) => {\n  const minutes = Math.floor(time / 60);\n  const seconds = Math.floor(time % 60);\n  return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n};\n\n\nexport default AudioWaveform;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}