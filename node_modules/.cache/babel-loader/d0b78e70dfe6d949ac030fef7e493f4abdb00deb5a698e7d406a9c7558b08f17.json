{"ast":null,"code":"var _jsxFileName = \"/home/gleb/my_app_test/src/audio/AudioWaveform.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { Popover } from '@material-ui/core';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WaveformContainer = styled.div`\n  width: 100%;\n  height: 100px;\n  position: relative;\n  background-color: #f1f3f4;\n  border-radius: 4px;\n  overflow: hidden;\n  cursor: pointer;\n  padding: 30px 0px;\n`;\n_c = WaveformContainer;\nconst WaveformCanvas = styled.canvas`\n  width: 100%;\n  height: 100%;\n  background-color: #f4h2a1;\n`;\n_c2 = WaveformCanvas;\nconst ProgressOverlay = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: ${props => props.progress}%;\n  background-color: rgba(255, 85, 0, 0.2);\n  pointer-events: none;\n`;\n_c3 = ProgressOverlay;\nconst AudioWaveform = ({\n  audioUrl,\n  currentTime,\n  duration,\n  isPlaying,\n  onSeek,\n  onPlayPause,\n  segments,\n  keywords\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const containerRef = useRef(null);\n  const [waveformData, setWaveformData] = useState([]);\n  const [hoveredKeyword, setHoveredKeyword] = useState(null);\n  const [anchorEl, setAnchorEl] = useState(null);\n  useEffect(() => {\n    if (audioUrl) {\n      fetchAudioAndComputeWaveform(audioUrl);\n    }\n  }, [audioUrl]);\n  useEffect(() => {\n    drawWaveform();\n  }, [waveformData, currentTime]);\n  const fetchAudioAndComputeWaveform = async url => {\n    try {\n      const response = await fetch(url);\n      const arrayBuffer = await response.arrayBuffer();\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n      const waveform = computeWaveform(audioBuffer);\n      setWaveformData(waveform);\n    } catch (error) {\n      console.error('Error fetching audio:', error);\n    }\n  };\n  const computeWaveform = audioBuffer => {\n    const channelData = audioBuffer.getChannelData(0);\n    const samples = 500;\n    const blockSize = Math.floor(channelData.length / samples);\n    const waveform = [];\n    for (let i = 0; i < samples; i++) {\n      const start = i * blockSize;\n      const end = start + blockSize;\n      let max = 0;\n      for (let j = start; j < end; j++) {\n        const amplitude = Math.abs(channelData[j]);\n        if (amplitude > max) {\n          max = amplitude;\n        }\n      }\n      waveform.push(max);\n    }\n    return waveform;\n  };\n  const drawWaveform = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    const width = canvas.width;\n    const height = canvas.height;\n    const barWidth = width / waveformData.length;\n    ctx.clearRect(0, 0, width, height);\n    waveformData.forEach((value, index) => {\n      const x = index * barWidth;\n      const barHeight = value * height;\n      ctx.fillStyle = currentTime / duration > index / waveformData.length ? '#ff5500' : '#999';\n      ctx.fillRect(x, (height - barHeight) / 2, barWidth - 1, barHeight);\n    });\n    segments.forEach(segment => {\n      const startX = segment.Start / duration * width;\n      const endX = segment.End / duration * width;\n      ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\" ? \"rgba(181, 201, 255, 0.5)\" : \"rgba(0, 123, 255, 0.5)\";\n      ctx.fillRect(startX, 0, endX - startX, height);\n    });\n\n    // Отрисовка ключевых слов\n    keywords.forEach(kw => {\n      const startX = kw.keyword.Start / duration * width;\n      ctx.fillStyle = kw.color;\n      ctx.fillRect(startX, 0.5, 1, height / 2);\n    });\n  };\n  const handleClick = e => {\n    if (!containerRef.current) return;\n    const rect = containerRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const seekTime = x / rect.width * duration;\n    onSeek(seekTime);\n  };\n  const handleMouseMove = e => {\n    const rect = containerRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const time = x / rect.width * duration;\n    const hoveredKw = keywords.find(kw => time >= kw.keyword.Start && time <= kw.keyword.End);\n    if (hoveredKw) {\n      setHoveredKeyword(hoveredKw);\n      setAnchorEl(e.currentTarget);\n    } else {\n      setHoveredKeyword(null);\n      setAnchorEl(null);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(WaveformContainer, {\n    ref: containerRef,\n    onClick: handleClick,\n    onMouseMove: handleMouseMove,\n    children: [/*#__PURE__*/_jsxDEV(WaveformCanvas, {\n      ref: canvasRef,\n      width: 1000,\n      height: 200\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 180,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(ProgressOverlay, {\n      progress: currentTime / duration * 100\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 181,\n      columnNumber: 7\n    }, this), hoveredKeyword && /*#__PURE__*/_jsxDEV(Popover, {\n      open: Boolean(anchorEl),\n      anchorEl: anchorEl,\n      onClose: () => setAnchorEl(null),\n      anchorOrigin: {\n        vertical: 'top',\n        horizontal: 'left'\n      },\n      transformOrigin: {\n        vertical: 'top',\n        horizontal: 'center'\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          padding: '10px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          children: [hoveredKeyword.keyword.Name, \" (\", (hoveredKeyword.keyword.Confidence * 100).toFixed(0), \"%)\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 197,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [formatTime(hoveredKeyword.keyword.Start), \" - \", formatTime(hoveredKeyword.keyword.End)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 198,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 196,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 183,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 175,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioWaveform, \"utLdhnp3A2jTa3/3BKHZvNHmb10=\");\n_c4 = AudioWaveform;\nconst formatTime = time => {\n  const minutes = Math.floor(time / 60);\n  const seconds = Math.floor(time % 60);\n  return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n};\nexport default AudioWaveform;\nvar _c, _c2, _c3, _c4;\n$RefreshReg$(_c, \"WaveformContainer\");\n$RefreshReg$(_c2, \"WaveformCanvas\");\n$RefreshReg$(_c3, \"ProgressOverlay\");\n$RefreshReg$(_c4, \"AudioWaveform\");","map":{"version":3,"names":["React","useRef","useEffect","useState","styled","Popover","jsxDEV","_jsxDEV","WaveformContainer","div","_c","WaveformCanvas","canvas","_c2","ProgressOverlay","props","progress","_c3","AudioWaveform","audioUrl","currentTime","duration","isPlaying","onSeek","onPlayPause","segments","keywords","_s","canvasRef","containerRef","waveformData","setWaveformData","hoveredKeyword","setHoveredKeyword","anchorEl","setAnchorEl","fetchAudioAndComputeWaveform","drawWaveform","url","response","fetch","arrayBuffer","audioContext","window","AudioContext","webkitAudioContext","audioBuffer","decodeAudioData","waveform","computeWaveform","error","console","channelData","getChannelData","samples","blockSize","Math","floor","length","i","start","end","max","j","amplitude","abs","push","current","ctx","getContext","width","height","barWidth","clearRect","forEach","value","index","x","barHeight","fillStyle","fillRect","segment","startX","Start","endX","End","Words","NormalForm","kw","keyword","color","handleClick","e","rect","getBoundingClientRect","clientX","left","seekTime","handleMouseMove","time","hoveredKw","find","currentTarget","ref","onClick","onMouseMove","children","fileName","_jsxFileName","lineNumber","columnNumber","open","Boolean","onClose","anchorOrigin","vertical","horizontal","transformOrigin","style","padding","Name","Confidence","toFixed","formatTime","_c4","minutes","seconds","$RefreshReg$"],"sources":["/home/gleb/my_app_test/src/audio/AudioWaveform.tsx"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { KeywordColor, SegmentModel } from './AudioContext';\nimport { Popover, Tooltip } from '@material-ui/core';\n\nconst WaveformContainer = styled.div`\n  width: 100%;\n  height: 100px;\n  position: relative;\n  background-color: #f1f3f4;\n  border-radius: 4px;\n  overflow: hidden;\n  cursor: pointer;\n  padding: 30px 0px;\n`;\n\nconst WaveformCanvas = styled.canvas`\n  width: 100%;\n  height: 100%;\n  background-color: #f4h2a1;\n`;\n\nconst ProgressOverlay = styled.div<{ progress: number }>`\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: ${props => props.progress}%;\n  background-color: rgba(255, 85, 0, 0.2);\n  pointer-events: none;\n`;\n\ninterface AudioWaveformProps {\n  audioUrl: string;\n  currentTime: number;\n  duration: number;\n  isPlaying: boolean;\n  onSeek: (time: number) => void;\n  onPlayPause: () => void;\n  segments: SegmentModel[];\n  keywords: KeywordColor[];\n}\n\nconst AudioWaveform: React.FC<AudioWaveformProps> = ({\n  audioUrl,\n  currentTime,\n  duration,\n  isPlaying,\n  onSeek,\n  onPlayPause,\n  segments,\n  keywords\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [waveformData, setWaveformData] = useState<number[]>([]);\n  const [hoveredKeyword, setHoveredKeyword] = useState<KeywordColor | null>(null);\n  const [anchorEl, setAnchorEl] = useState<HTMLElement | null>(null);\n\n  useEffect(() => {\n    if (audioUrl) {\n      fetchAudioAndComputeWaveform(audioUrl);\n    }\n  }, [audioUrl]);\n\n  useEffect(() => {\n    drawWaveform();\n  }, [waveformData, currentTime]);\n\n  const fetchAudioAndComputeWaveform = async (url: string) => {\n    try {\n      const response = await fetch(url);\n      const arrayBuffer = await response.arrayBuffer();\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n      const waveform = computeWaveform(audioBuffer);\n      setWaveformData(waveform);\n    } catch (error) {\n      console.error('Error fetching audio:', error);\n    }\n  };\n\n  const computeWaveform = (audioBuffer: AudioBuffer) => {\n    const channelData = audioBuffer.getChannelData(0);\n    const samples = 500;\n    const blockSize = Math.floor(channelData.length / samples);\n    const waveform = [];\n\n    for (let i = 0; i < samples; i++) {\n      const start = i * blockSize;\n      const end = start + blockSize;\n      let max = 0;\n      for (let j = start; j < end; j++) {\n        const amplitude = Math.abs(channelData[j]);\n        if (amplitude > max) {\n          max = amplitude;\n        }\n      }\n      waveform.push(max);\n    }\n\n    return waveform;\n  };\n\n  const drawWaveform = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    const width = canvas.width;\n    const height = canvas.height;\n    const barWidth = width / waveformData.length;\n    \n\n    ctx.clearRect(0, 0, width, height);\n\n    waveformData.forEach((value, index) => {\n      const x = index * barWidth;\n      const barHeight = value * height;\n\n      ctx.fillStyle = currentTime / duration > index / waveformData.length ? '#ff5500' : '#999';\n      ctx.fillRect(x, (height - barHeight) / 2, barWidth - 1, barHeight);\n    });\n\n    segments.forEach((segment) => {\n      const startX = (segment.Start / duration) * width;\n      const endX = (segment.End / duration) * width;\n      ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\"\n        ? \"rgba(181, 201, 255, 0.5)\"\n        : \"rgba(0, 123, 255, 0.5)\";\n      ctx.fillRect(startX, 0, endX - startX, height);\n    });\n\n    // Отрисовка ключевых слов\n    keywords.forEach((kw) => {\n      \n      const startX = (kw.keyword.Start / duration) * width;\n      ctx.fillStyle = kw.color;\n      ctx.fillRect(startX, 0.5, 1, height / 2 );\n    });\n    \n  };\n\n  const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    if (!containerRef.current) return;\n    const rect = containerRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const seekTime = (x / rect.width) * duration;\n    onSeek(seekTime);\n  };\n\n  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {\n    const rect = containerRef.current!.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const time = (x / rect.width) * duration;\n  \n    const hoveredKw = keywords.find(kw => \n      time >= kw.keyword.Start && time <= kw.keyword.End\n    );\n  \n    if (hoveredKw) {\n      setHoveredKeyword(hoveredKw);\n      setAnchorEl(e.currentTarget);\n    } else {\n      setHoveredKeyword(null);\n      setAnchorEl(null);\n    }\n  };\n\n\n \n  return (\n    <WaveformContainer \n      ref={containerRef} \n      onClick={handleClick} \n      onMouseMove={handleMouseMove}\n    >\n      <WaveformCanvas ref={canvasRef} width={1000} height={200} />\n      <ProgressOverlay progress={(currentTime / duration) * 100} />\n      {hoveredKeyword && (\n        <Popover\n          open={Boolean(anchorEl)}\n          anchorEl={anchorEl}\n          onClose={() => setAnchorEl(null)}\n          anchorOrigin={{\n            vertical: 'top',\n            horizontal: 'left',\n          }}\n          transformOrigin={{\n            vertical: 'top',\n            horizontal: 'center',\n          }}\n        >\n          <div style={{ padding: '10px' }}>\n            <div>{hoveredKeyword.keyword.Name} ({(hoveredKeyword.keyword.Confidence * 100).toFixed(0)}%)</div>\n            <div>{formatTime(hoveredKeyword.keyword.Start)} - {formatTime(hoveredKeyword.keyword.End)}</div>\n          </div>\n        </Popover>\n      )}\n    </WaveformContainer>\n  );\n};\n\nconst formatTime = (time: number) => {\n  const minutes = Math.floor(time / 60);\n  const seconds = Math.floor(time % 60);\n  return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n};\n\n\nexport default AudioWaveform;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}