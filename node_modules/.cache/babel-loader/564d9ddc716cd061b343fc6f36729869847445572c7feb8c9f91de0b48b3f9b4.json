{"ast":null,"code":"var _jsxFileName = \"/home/gleb/my_app_test/src/audio/r6/Player.tsx\",\n  _s = $RefreshSig$();\n// import React, { useState, useRef, useEffect } from 'react';\n// import { makeStyles } from '@material-ui/core/styles';\n// import { IconButton, Slider } from '@material-ui/core';\n// import { PlayArrow, Pause } from '@material-ui/icons';\n\n// interface PlayerProps {\n//   audioSrc: string;\n//   segments: SegmentModel[];\n//   keywords: KeywordColor[];\n// }\n\n// interface SegmentModel {\n//   Start: number;\n//   End: number;\n//   ChannelNumber: number;\n//   Words?: { NormalForm: string }[];\n// }\n\n// interface KeywordColor {\n//   keyword: {\n//     Start: number;\n//     End: number;\n//     Name: string;\n//     ChannelNumber: number;\n//     Confidence: number;\n//   };\n//   color: string;\n// }\n\n// const useStyles = makeStyles({\n//   root: {\n//     width: '100%',\n//     display: 'flex',\n//     flexDirection: 'column',\n//     alignItems: 'center',\n//   },\n//   controls: {\n//     display: 'flex',\n//     alignItems: 'center',\n//     width: '100%',\n//     marginBottom: 20,\n//     marginTop: 100,\n//   },\n//   canvas: {\n//     width: '100%',\n//     height: 100,\n//     border: '1px solid black', // Added for visibility\n//   },\n// });\n\n// const Player: React.FC<PlayerProps> = ({ audioSrc, segments, keywords }) => {\n//   const classes = useStyles();\n//   const [isPlaying, setIsPlaying] = useState(false);\n//   const [currentTime, setCurrentTime] = useState(0);\n//   const [duration, setDuration] = useState(0);\n\n//   const audioRef = useRef<HTMLAudioElement>(null);\n//   const canvasRef = useRef<HTMLCanvasElement>(null);\n\n//   useEffect(() => {\n//     if (audioRef.current) {\n//       audioRef.current.addEventListener('loadedmetadata', () => {\n//         setDuration(audioRef.current!.duration);\n//       });\n//       audioRef.current.addEventListener('timeupdate', () => {\n//         setCurrentTime(audioRef.current!.currentTime);\n//       });\n//     }\n//   }, []);\n\n//   useEffect(() => {\n//     drawWaveform();\n//   }, [segments, keywords, duration]);\n\n//   const togglePlay = () => {\n//     if (audioRef.current) {\n//       if (isPlaying) {\n//         audioRef.current.pause();\n//       } else {\n//         audioRef.current.play();\n//       }\n//       setIsPlaying(!isPlaying);\n//     }\n//   };\n\n//   const handleSliderChange = (event: any, newValue: number | number[]) => {\n//     if (audioRef.current && typeof newValue === 'number') {\n//       audioRef.current.currentTime = newValue;\n//       setCurrentTime(newValue);\n//     }\n//   };\n\n//   const drawWaveform = () => {\n//     if (canvasRef.current && duration > 0) {\n//       const ctx = canvasRef.current.getContext('2d');\n//       if (ctx) {\n//         const canvasWidth = canvasRef.current.width;\n//         const canvasHeight = canvasRef.current.height;\n\n//         ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n//         console.log(`Drawing ${segments.length} segments and ${keywords.length} keywords`);\n\n//         // Draw segments\n//         segments.forEach((segment, index) => {\n//             const startX = (segment.Start / duration) * canvasWidth;\n//             const endX = (segment.End / duration) * canvasWidth;\n//             ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\"\n//               ? \"rgba(181, 201, 255, 0.5)\"\n//               : \"rgba(0, 123, 255, 0.5)\";\n//             ctx.fillRect(startX, 0, endX - startX, canvasHeight);\n//             console.log(`Drawing segment ${index}: start=${startX}, end=${endX}, color=${ctx.fillStyle}`);\n//           });\n\n//           // Draw keywords\n//           keywords.forEach((kw, index) => {\n//             const startX = (kw.keyword.Start / duration) * canvasWidth;\n//             const width = ((kw.keyword.End - kw.keyword.Start) / duration) * canvasWidth;\n//             ctx.fillStyle = kw.color;\n//             ctx.fillRect(startX, 0, width, canvasHeight / 4);\n//             console.log(`Drawing keyword ${index}: start=${startX}, width=${width}, color=${kw.color}`);\n//           });\n\n//           // Draw current time indicator\n//           const currentTimeX = (currentTime / duration) * canvasWidth;\n//           ctx.strokeStyle = 'red';\n//           ctx.lineWidth = 2;\n//           ctx.beginPath();\n//           ctx.moveTo(currentTimeX, 0);\n//           ctx.lineTo(currentTimeX, canvasHeight);\n//           ctx.stroke();\n//         }\n//       } else {\n//         console.log('Canvas not ready or duration is 0');\n//       }\n//     };\n\n//     const formatTime = (time: number) => {\n//       const minutes = Math.floor(time / 60);\n//       const seconds = Math.floor(time % 60);\n//       return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n//     };\n\n//     return (\n//       <div className={classes.root}>\n//         <audio ref={audioRef} src={audioSrc} />\n//         <div className={classes.controls}>\n//           <IconButton onClick={togglePlay}>\n//             {isPlaying ? <Pause /> : <PlayArrow />}\n//           </IconButton>\n//           <Slider\n//             value={currentTime}\n//             onChange={handleSliderChange}\n//             min={0}\n//             max={duration}\n//             step={0.1}\n//           />\n//           <span>{formatTime(currentTime)} / {formatTime(duration)}</span>\n//         </div>\n//         <canvas \n//           ref={canvasRef} \n//           className={classes.canvas}\n//           width={1000}\n//           height={100}\n//           onClick={(e) => {\n//             const rect = canvasRef.current!.getBoundingClientRect();\n//             const x = e.clientX - rect.left;\n//             const clickTime = (x / canvasRef.current!.width) * duration;\n//             if (audioRef.current) {\n//               audioRef.current.currentTime = clickTime;\n//             }\n//           }}\n//         />\n//         <div>\n//           <p>Segments: {segments.length}</p>\n//           <p>Keywords: {keywords.length}</p>\n//           <p>Duration: {duration}</p>\n//         </div>\n//       </div>\n//     );\n//   };\n\n//   export default Player;\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport { IconButton, Slider, Tooltip } from '@material-ui/core';\nimport { PlayArrow, Pause } from '@material-ui/icons';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst useStyles = makeStyles({\n  root: {\n    width: '90%',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center'\n  },\n  controls: {\n    display: 'flex',\n    alignItems: 'center',\n    width: '100%',\n    margin: '20px 0'\n  },\n  canvasContainer: {\n    width: '100%',\n    display: 'flex',\n    flexDirection: 'column'\n  },\n  canvas: {\n    width: '90%',\n    height: 50,\n    marginBottom: 10\n  },\n  tooltipAnchor: {\n    position: 'absolute',\n    width: 1,\n    height: 1\n  }\n});\nconst Player = ({\n  audioSrc,\n  segments,\n  keywords\n}) => {\n  _s();\n  const classes = useStyles();\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [hoveredKeyword, setHoveredKeyword] = useState(null);\n  const [tooltipPosition, setTooltipPosition] = useState({\n    top: 0,\n    left: 0\n  });\n  const audioRef = useRef(null);\n  const canvasRef1 = useRef(null);\n  const canvasRef2 = useRef(null);\n  useEffect(() => {\n    if (audioRef.current) {\n      audioRef.current.addEventListener('loadedmetadata', () => {\n        setDuration(audioRef.current.duration);\n      });\n      audioRef.current.addEventListener('timeupdate', () => {\n        setCurrentTime(audioRef.current.currentTime);\n      });\n    }\n  }, []);\n  useEffect(() => {\n    drawWaveform();\n  }, [segments, keywords, duration]);\n  const togglePlay = () => {\n    if (audioRef.current) {\n      if (isPlaying) {\n        audioRef.current.pause();\n      } else {\n        audioRef.current.play();\n      }\n      setIsPlaying(!isPlaying);\n    }\n  };\n  const handleSliderChange = (event, newValue) => {\n    if (audioRef.current && typeof newValue === 'number') {\n      audioRef.current.currentTime = newValue;\n      setCurrentTime(newValue);\n    }\n  };\n  const drawWaveform = () => {\n    if (canvasRef1.current && canvasRef2.current && duration > 0) {\n      const drawChannel = (ctx, channelSegments, channelKeywords) => {\n        var _channelSegments$;\n        const canvasWidth = ctx.canvas.width;\n        const canvasHeight = ctx.canvas.height;\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n        // Draw segments\n        channelSegments.forEach(segment => {\n          const startX = segment.Start / duration * canvasWidth;\n          const endX = segment.End / duration * canvasWidth;\n          ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\" ? \"rgba(181, 201, 255, 0.5)\" : \"rgba(0, 123, 255, 0.5)\";\n          ctx.fillRect(startX, 0, endX - startX, canvasHeight);\n        });\n\n        // Draw keywords\n        channelKeywords.forEach(kw => {\n          const startX = kw.keyword.Start / duration * canvasWidth;\n          const width = 2;\n          ctx.fillStyle = kw.color;\n          ctx.fillRect(startX, 0, width, canvasHeight);\n        });\n        console.log(`Channel ${(_channelSegments$ = channelSegments[0]) === null || _channelSegments$ === void 0 ? void 0 : _channelSegments$.ChannelNumber}: ${channelSegments.length} segments, ${channelKeywords.length} keywords`);\n        console.log('Keywords:', channelKeywords);\n      };\n      const ctx1 = canvasRef1.current.getContext('2d');\n      const ctx2 = canvasRef2.current.getContext('2d');\n      if (ctx1 && ctx2) {\n        const channel1Segments = segments.filter(s => s.ChannelNumber === 1);\n        const channel2Segments = segments.filter(s => s.ChannelNumber === 2);\n        const channel1Keywords = keywords.filter(k => k.keyword.ChannelNumber === 1);\n        const channel2Keywords = keywords.filter(k => k.keyword.ChannelNumber === 2);\n        console.log('All keywords:', keywords);\n        console.log('Channel 1 keywords:', channel1Keywords);\n        console.log('Channel 2 keywords:', channel2Keywords);\n        drawChannel(ctx1, channel1Segments, channel1Keywords);\n        drawChannel(ctx2, channel2Segments, channel2Keywords);\n\n        // Draw current time indicator\n        const currentTimeX = currentTime / duration * ctx1.canvas.width;\n        [ctx1, ctx2].forEach(ctx => {\n          ctx.strokeStyle = 'red';\n          ctx.lineWidth = 2;\n          ctx.beginPath();\n          ctx.moveTo(currentTimeX, 0);\n          ctx.lineTo(currentTimeX, ctx.canvas.height);\n          ctx.stroke();\n        });\n      }\n    }\n  };\n  const handleCanvasMouseMove = (event, channelKeywords) => {\n    const canvas = event.currentTarget;\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const time = x / canvas.width * duration;\n    const hoveredKw = channelKeywords.find(kw => time >= kw.keyword.Start && time <= kw.keyword.End);\n    setHoveredKeyword(hoveredKw || null);\n    setTooltipPosition({\n      top: event.clientY,\n      left: event.clientX\n    });\n  };\n  const handleCanvasMouseLeave = () => {\n    setHoveredKeyword(null);\n  };\n  const formatTime = time => {\n    const minutes = Math.floor(time / 60);\n    const seconds = Math.floor(time % 60);\n    return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: classes.root,\n    children: [/*#__PURE__*/_jsxDEV(\"audio\", {\n      ref: audioRef,\n      src: audioSrc\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 375,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: classes.canvasContainer,\n      children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef1,\n        className: classes.canvas,\n        width: 1000,\n        height: 50,\n        onMouseMove: e => handleCanvasMouseMove(e, keywords.filter(k => k.keyword.ChannelNumber === 1)),\n        onMouseLeave: handleCanvasMouseLeave\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 377,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: classes.controls,\n        children: [/*#__PURE__*/_jsxDEV(IconButton, {\n          onClick: togglePlay,\n          children: isPlaying ? /*#__PURE__*/_jsxDEV(Pause, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 387,\n            columnNumber: 26\n          }, this) : /*#__PURE__*/_jsxDEV(PlayArrow, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 387,\n            columnNumber: 38\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 386,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Slider, {\n          value: currentTime,\n          onChange: handleSliderChange,\n          min: 0,\n          max: duration,\n          step: 0.1\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 389,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: [formatTime(currentTime), \" / \", formatTime(duration)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 396,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 385,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef2,\n        className: classes.canvas,\n        width: 1000,\n        height: 50,\n        onMouseMove: e => handleCanvasMouseMove(e, keywords.filter(k => k.keyword.ChannelNumber === 2)),\n        onMouseLeave: handleCanvasMouseLeave\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 398,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 376,\n      columnNumber: 7\n    }, this), hoveredKeyword && /*#__PURE__*/_jsxDEV(Tooltip, {\n      title: `${hoveredKeyword.keyword.Name} (${formatTime(hoveredKeyword.keyword.Start)} - ${formatTime(hoveredKeyword.keyword.End)})`,\n      open: true,\n      placement: \"top\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: classes.tooltipAnchor,\n        style: {\n          top: tooltipPosition.top,\n          left: tooltipPosition.left\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 413,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 408,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 374,\n    columnNumber: 5\n  }, this);\n};\n_s(Player, \"GFufXNUDySZZuxysXAxanDKyMQU=\", false, function () {\n  return [useStyles];\n});\n_c = Player;\nexport default Player;\nvar _c;\n$RefreshReg$(_c, \"Player\");","map":{"version":3,"names":["React","useState","useRef","useEffect","makeStyles","IconButton","Slider","Tooltip","PlayArrow","Pause","jsxDEV","_jsxDEV","useStyles","root","width","display","flexDirection","alignItems","controls","margin","canvasContainer","canvas","height","marginBottom","tooltipAnchor","position","Player","audioSrc","segments","keywords","_s","classes","isPlaying","setIsPlaying","currentTime","setCurrentTime","duration","setDuration","hoveredKeyword","setHoveredKeyword","tooltipPosition","setTooltipPosition","top","left","audioRef","canvasRef1","canvasRef2","current","addEventListener","drawWaveform","togglePlay","pause","play","handleSliderChange","event","newValue","drawChannel","ctx","channelSegments","channelKeywords","_channelSegments$","canvasWidth","canvasHeight","clearRect","forEach","segment","startX","Start","endX","End","fillStyle","Words","NormalForm","fillRect","kw","keyword","color","console","log","ChannelNumber","length","ctx1","getContext","ctx2","channel1Segments","filter","s","channel2Segments","channel1Keywords","k","channel2Keywords","currentTimeX","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","handleCanvasMouseMove","currentTarget","rect","getBoundingClientRect","x","clientX","time","hoveredKw","find","clientY","handleCanvasMouseLeave","formatTime","minutes","Math","floor","seconds","className","children","ref","src","fileName","_jsxFileName","lineNumber","columnNumber","onMouseMove","e","onMouseLeave","onClick","value","onChange","min","max","step","title","Name","open","placement","style","_c","$RefreshReg$"],"sources":["/home/gleb/my_app_test/src/audio/r6/Player.tsx"],"sourcesContent":["// import React, { useState, useRef, useEffect } from 'react';\n// import { makeStyles } from '@material-ui/core/styles';\n// import { IconButton, Slider } from '@material-ui/core';\n// import { PlayArrow, Pause } from '@material-ui/icons';\n\n// interface PlayerProps {\n//   audioSrc: string;\n//   segments: SegmentModel[];\n//   keywords: KeywordColor[];\n// }\n\n// interface SegmentModel {\n//   Start: number;\n//   End: number;\n//   ChannelNumber: number;\n//   Words?: { NormalForm: string }[];\n// }\n\n// interface KeywordColor {\n//   keyword: {\n//     Start: number;\n//     End: number;\n//     Name: string;\n//     ChannelNumber: number;\n//     Confidence: number;\n//   };\n//   color: string;\n// }\n\n// const useStyles = makeStyles({\n//   root: {\n//     width: '100%',\n//     display: 'flex',\n//     flexDirection: 'column',\n//     alignItems: 'center',\n//   },\n//   controls: {\n//     display: 'flex',\n//     alignItems: 'center',\n//     width: '100%',\n//     marginBottom: 20,\n//     marginTop: 100,\n//   },\n//   canvas: {\n//     width: '100%',\n//     height: 100,\n//     border: '1px solid black', // Added for visibility\n//   },\n// });\n\n// const Player: React.FC<PlayerProps> = ({ audioSrc, segments, keywords }) => {\n//   const classes = useStyles();\n//   const [isPlaying, setIsPlaying] = useState(false);\n//   const [currentTime, setCurrentTime] = useState(0);\n//   const [duration, setDuration] = useState(0);\n  \n//   const audioRef = useRef<HTMLAudioElement>(null);\n//   const canvasRef = useRef<HTMLCanvasElement>(null);\n\n//   useEffect(() => {\n//     if (audioRef.current) {\n//       audioRef.current.addEventListener('loadedmetadata', () => {\n//         setDuration(audioRef.current!.duration);\n//       });\n//       audioRef.current.addEventListener('timeupdate', () => {\n//         setCurrentTime(audioRef.current!.currentTime);\n//       });\n//     }\n//   }, []);\n\n//   useEffect(() => {\n//     drawWaveform();\n//   }, [segments, keywords, duration]);\n\n//   const togglePlay = () => {\n//     if (audioRef.current) {\n//       if (isPlaying) {\n//         audioRef.current.pause();\n//       } else {\n//         audioRef.current.play();\n//       }\n//       setIsPlaying(!isPlaying);\n//     }\n//   };\n\n//   const handleSliderChange = (event: any, newValue: number | number[]) => {\n//     if (audioRef.current && typeof newValue === 'number') {\n//       audioRef.current.currentTime = newValue;\n//       setCurrentTime(newValue);\n//     }\n//   };\n\n//   const drawWaveform = () => {\n//     if (canvasRef.current && duration > 0) {\n//       const ctx = canvasRef.current.getContext('2d');\n//       if (ctx) {\n//         const canvasWidth = canvasRef.current.width;\n//         const canvasHeight = canvasRef.current.height;\n\n//         ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        \n//         console.log(`Drawing ${segments.length} segments and ${keywords.length} keywords`);\n        \n//         // Draw segments\n//         segments.forEach((segment, index) => {\n//             const startX = (segment.Start / duration) * canvasWidth;\n//             const endX = (segment.End / duration) * canvasWidth;\n//             ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\"\n//               ? \"rgba(181, 201, 255, 0.5)\"\n//               : \"rgba(0, 123, 255, 0.5)\";\n//             ctx.fillRect(startX, 0, endX - startX, canvasHeight);\n//             console.log(`Drawing segment ${index}: start=${startX}, end=${endX}, color=${ctx.fillStyle}`);\n//           });\n  \n//           // Draw keywords\n//           keywords.forEach((kw, index) => {\n//             const startX = (kw.keyword.Start / duration) * canvasWidth;\n//             const width = ((kw.keyword.End - kw.keyword.Start) / duration) * canvasWidth;\n//             ctx.fillStyle = kw.color;\n//             ctx.fillRect(startX, 0, width, canvasHeight / 4);\n//             console.log(`Drawing keyword ${index}: start=${startX}, width=${width}, color=${kw.color}`);\n//           });\n  \n//           // Draw current time indicator\n//           const currentTimeX = (currentTime / duration) * canvasWidth;\n//           ctx.strokeStyle = 'red';\n//           ctx.lineWidth = 2;\n//           ctx.beginPath();\n//           ctx.moveTo(currentTimeX, 0);\n//           ctx.lineTo(currentTimeX, canvasHeight);\n//           ctx.stroke();\n//         }\n//       } else {\n//         console.log('Canvas not ready or duration is 0');\n//       }\n//     };\n  \n//     const formatTime = (time: number) => {\n//       const minutes = Math.floor(time / 60);\n//       const seconds = Math.floor(time % 60);\n//       return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n//     };\n  \n//     return (\n//       <div className={classes.root}>\n//         <audio ref={audioRef} src={audioSrc} />\n//         <div className={classes.controls}>\n//           <IconButton onClick={togglePlay}>\n//             {isPlaying ? <Pause /> : <PlayArrow />}\n//           </IconButton>\n//           <Slider\n//             value={currentTime}\n//             onChange={handleSliderChange}\n//             min={0}\n//             max={duration}\n//             step={0.1}\n//           />\n//           <span>{formatTime(currentTime)} / {formatTime(duration)}</span>\n//         </div>\n//         <canvas \n//           ref={canvasRef} \n//           className={classes.canvas}\n//           width={1000}\n//           height={100}\n//           onClick={(e) => {\n//             const rect = canvasRef.current!.getBoundingClientRect();\n//             const x = e.clientX - rect.left;\n//             const clickTime = (x / canvasRef.current!.width) * duration;\n//             if (audioRef.current) {\n//               audioRef.current.currentTime = clickTime;\n//             }\n//           }}\n//         />\n//         <div>\n//           <p>Segments: {segments.length}</p>\n//           <p>Keywords: {keywords.length}</p>\n//           <p>Duration: {duration}</p>\n//         </div>\n//       </div>\n//     );\n//   };\n  \n//   export default Player;\n\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport { IconButton, Slider, Tooltip } from '@material-ui/core';\nimport { PlayArrow, Pause } from '@material-ui/icons';\n\ninterface PlayerProps {\n  audioSrc: string;\n  segments: SegmentModel[];\n  keywords: KeywordColor[];\n}\n\ninterface SegmentModel {\n  Start: number;\n  End: number;\n  ChannelNumber: number;\n  Words?: { NormalForm: string }[];\n}\n\ninterface KeywordColor {\n  keyword: {\n    Start: number;\n    End: number;\n    Name: string;\n    ChannelNumber: number;\n    Confidence: number;\n  };\n  color: string;\n}\n\nconst useStyles = makeStyles({\n  root: {\n    width: '90%',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n  },\n  controls: {\n    display: 'flex',\n    alignItems: 'center',\n    width: '100%',\n    margin: '20px 0',\n  },\n  canvasContainer: {\n    width: '100%',\n    display: 'flex',\n    flexDirection: 'column',\n  },\n  canvas: {\n    width: '90%',\n    height: 50,\n    marginBottom: 10,\n  },\n  tooltipAnchor: {\n    position: 'absolute',\n    width: 1,\n    height: 1,\n  },\n});\n\nconst Player: React.FC<PlayerProps> = ({ audioSrc, segments, keywords }) => {\n    const classes = useStyles();\n    const [isPlaying, setIsPlaying] = useState(false);\n    const [currentTime, setCurrentTime] = useState(0);\n    const [duration, setDuration] = useState(0);\n    const [hoveredKeyword, setHoveredKeyword] = useState<KeywordColor | null>(null);\n    const [tooltipPosition, setTooltipPosition] = useState({ top: 0, left: 0 });\n    \n    const audioRef = useRef<HTMLAudioElement>(null);\n    const canvasRef1 = useRef<HTMLCanvasElement>(null);\n    const canvasRef2 = useRef<HTMLCanvasElement>(null);\n\n    useEffect(() => {\n    if (audioRef.current) {\n      audioRef.current.addEventListener('loadedmetadata', () => {\n        setDuration(audioRef.current!.duration);\n      });\n      audioRef.current.addEventListener('timeupdate', () => {\n        setCurrentTime(audioRef.current!.currentTime);\n      });\n    }\n  }, []);\n\n  useEffect(() => {\n    drawWaveform();\n  }, [segments, keywords, duration]);\n\n  const togglePlay = () => {\n    if (audioRef.current) {\n      if (isPlaying) {\n        audioRef.current.pause();\n      } else {\n        audioRef.current.play();\n      }\n      setIsPlaying(!isPlaying);\n    }\n  };\n\n  const handleSliderChange = (event: any, newValue: number | number[]) => {\n    if (audioRef.current && typeof newValue === 'number') {\n      audioRef.current.currentTime = newValue;\n      setCurrentTime(newValue);\n    }\n  };\n\n  const drawWaveform = () => {\n    if (canvasRef1.current && canvasRef2.current && duration > 0) {\n      const drawChannel = (ctx: CanvasRenderingContext2D, channelSegments: SegmentModel[], channelKeywords: KeywordColor[]) => {\n        const canvasWidth = ctx.canvas.width;\n        const canvasHeight = ctx.canvas.height;\n\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        \n        // Draw segments\n        channelSegments.forEach((segment) => {\n          const startX = (segment.Start / duration) * canvasWidth;\n          const endX = (segment.End / duration) * canvasWidth;\n          ctx.fillStyle = segment.Words && segment.Words[0].NormalForm === \"[music]\"\n            ? \"rgba(181, 201, 255, 0.5)\"\n            : \"rgba(0, 123, 255, 0.5)\";\n          ctx.fillRect(startX, 0, endX - startX, canvasHeight);\n        });\n\n        // Draw keywords\n        channelKeywords.forEach((kw) => {\n          const startX = (kw.keyword.Start / duration) * canvasWidth;\n          const width = 2;\n          ctx.fillStyle = kw.color;\n          ctx.fillRect(startX, 0, width, canvasHeight);\n        });\n        console.log(`Channel ${channelSegments[0]?.ChannelNumber}: ${channelSegments.length} segments, ${channelKeywords.length} keywords`);\n        console.log('Keywords:', channelKeywords);\n      };\n\n      const ctx1 = canvasRef1.current.getContext('2d');\n      const ctx2 = canvasRef2.current.getContext('2d');\n\n      if (ctx1 && ctx2) {\n        const channel1Segments = segments.filter(s => s.ChannelNumber === 1);\n        const channel2Segments = segments.filter(s => s.ChannelNumber === 2);\n        const channel1Keywords = keywords.filter(k => k.keyword.ChannelNumber === 1);\n        const channel2Keywords = keywords.filter(k => k.keyword.ChannelNumber === 2);\n\n        console.log('All keywords:', keywords);\n        console.log('Channel 1 keywords:', channel1Keywords);\n        console.log('Channel 2 keywords:', channel2Keywords);\n\n        drawChannel(ctx1, channel1Segments, channel1Keywords);\n        drawChannel(ctx2, channel2Segments, channel2Keywords);\n\n        // Draw current time indicator\n        const currentTimeX = (currentTime / duration) * ctx1.canvas.width;\n        [ctx1, ctx2].forEach(ctx => {\n          ctx.strokeStyle = 'red';\n          ctx.lineWidth = 2;\n          ctx.beginPath();\n          ctx.moveTo(currentTimeX, 0);\n          ctx.lineTo(currentTimeX, ctx.canvas.height);\n          ctx.stroke();\n        });\n      }\n    }\n  };\n\n  const handleCanvasMouseMove = (event: React.MouseEvent<HTMLCanvasElement>, channelKeywords: KeywordColor[]) => {\n    const canvas = event.currentTarget;\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const time = (x / canvas.width) * duration;\n\n    const hoveredKw = channelKeywords.find(kw => \n      time >= kw.keyword.Start && time <= kw.keyword.End\n    );\n\n    setHoveredKeyword(hoveredKw || null);\n    setTooltipPosition({ top: event.clientY, left: event.clientX });\n  };\n\n  const handleCanvasMouseLeave = () => {\n    setHoveredKeyword(null);\n  };\n\n  const formatTime = (time: number) => {\n    const minutes = Math.floor(time / 60);\n    const seconds = Math.floor(time % 60);\n    return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n  };\n\n  return (\n    <div className={classes.root}>\n      <audio ref={audioRef} src={audioSrc} />\n      <div className={classes.canvasContainer}>\n        <canvas \n          ref={canvasRef1} \n          className={classes.canvas}\n          width={1000}\n          height={50}\n          onMouseMove={(e) => handleCanvasMouseMove(e, keywords.filter(k => k.keyword.ChannelNumber === 1))}\n          onMouseLeave={handleCanvasMouseLeave}\n        />\n        <div className={classes.controls}>\n          <IconButton onClick={togglePlay}>\n            {isPlaying ? <Pause /> : <PlayArrow />}\n          </IconButton>\n          <Slider\n            value={currentTime}\n            onChange={handleSliderChange}\n            min={0}\n            max={duration}\n            step={0.1}\n          />\n          <span>{formatTime(currentTime)} / {formatTime(duration)}</span>\n        </div>\n        <canvas \n          ref={canvasRef2} \n          className={classes.canvas}\n          width={1000}\n          height={50}\n          onMouseMove={(e) => handleCanvasMouseMove(e, keywords.filter(k => k.keyword.ChannelNumber === 2))}\n          onMouseLeave={handleCanvasMouseLeave}\n        />\n      </div>\n      {hoveredKeyword && (\n        <Tooltip\n          title={`${hoveredKeyword.keyword.Name} (${formatTime(hoveredKeyword.keyword.Start)} - ${formatTime(hoveredKeyword.keyword.End)})`}\n          open={true}\n          placement=\"top\"\n        >\n          <div \n            className={classes.tooltipAnchor}\n            style={{ top: tooltipPosition.top, left: tooltipPosition.left }}\n          />\n        </Tooltip>\n      )}\n    </div>\n  );\n};\n\nexport default Player;"],"mappings":";;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,MAAM,EAAEC,SAAS,QAAQ,OAAO;AAC1D,SAASC,UAAU,QAAQ,0BAA0B;AACrD,SAASC,UAAU,EAAEC,MAAM,EAAEC,OAAO,QAAQ,mBAAmB;AAC/D,SAASC,SAAS,EAAEC,KAAK,QAAQ,oBAAoB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AA0BtD,MAAMC,SAAS,GAAGR,UAAU,CAAC;EAC3BS,IAAI,EAAE;IACJC,KAAK,EAAE,KAAK;IACZC,OAAO,EAAE,MAAM;IACfC,aAAa,EAAE,QAAQ;IACvBC,UAAU,EAAE;EACd,CAAC;EACDC,QAAQ,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}